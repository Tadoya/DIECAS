;/*****************************************************
;This program was produced by the
;CodeWizardAVR V2.05.3 Standard
;Automatic Program Generator
;© Copyright 1998-2011 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com
;
;Project :
;Version :
;Date    : 2014-11-15
;Author  : PerTic@n
;Company : If You Like This Software,Buy It
;Comments:
;
;
;Chip type               : ATxmega128A1
;Program type            : Application
;AVR Core Clock frequency: 2.000000 MHz
;Memory model            : Small
;Data Stack size         : 2048
;*****************************************************/
;
;// I/O Registers definitions
;#include <io.h>
;
;// Standard Input/Output functions
;#include <stdio.h>
;#include <math.h>
;#include <stdlib.h>
;#include <string.h>
;// Delay functions
;#include <delay.h>
;
;// Declare your global variables here
;
;// System Clocks initialization
;void system_clocks_init(void)
; 0000 0026 {

	.CSEG
;PCODE: $00000000 VOL: 0
;PCODE: $00000001 VOL: 0
; 0000 0027 unsigned char n,s;
; 0000 0028 
; 0000 0029 // Optimize for speed
; 0000 002A #pragma optsize-
; 0000 002B // Save interrupts enabled/disabled state
; 0000 002C s=SREG;
;PCODE: $00000002 VOL: 0
;PCODE: $00000003 VOL: 0
;	n -> R17
;	s -> R16
;PCODE: $00000004 VOL: 0
;PCODE: $00000005 VOL: 0
; 0000 002D // Disable interrupts
; 0000 002E #asm("cli")
;PCODE: $00000006 VOL: 0
	cli
;PCODE: $00000007 VOL: 0
; 0000 002F 
; 0000 0030 // Internal 2 MHz RC oscillator initialization
; 0000 0031 // Enable the internal 2 MHz RC oscillator
; 0000 0032 OSC.CTRL|=OSC_RC2MEN_bm;
;PCODE: $00000008 VOL: 1
;PCODE: $00000009 VOL: 0
;PCODE: $0000000A VOL: 1
; 0000 0033 
; 0000 0034 // System Clock prescaler A division factor: 1
; 0000 0035 // System Clock prescalers B & C division factors: B:1, C:1
; 0000 0036 // ClkPer4: 2000.000 kHz
; 0000 0037 // ClkPer2: 2000.000 kHz
; 0000 0038 // ClkPer:  2000.000 kHz
; 0000 0039 // ClkCPU:  2000.000 kHz
; 0000 003A n=(CLK.PSCTRL & (~(CLK_PSADIV_gm | CLK_PSBCDIV1_bm | CLK_PSBCDIV0_bm))) |
; 0000 003B 	CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc;
;PCODE: $0000000B VOL: 1
;PCODE: $0000000C VOL: 0
;PCODE: $0000000D VOL: 0
;PCODE: $0000000E VOL: 0
;PCODE: $0000000F VOL: 0
; 0000 003C CCP=CCP_IOREG_gc;
;PCODE: $00000010 VOL: 0
;PCODE: $00000011 VOL: 0
; 0000 003D CLK.PSCTRL=n;
;PCODE: $00000012 VOL: 1
;PCODE: $00000013 VOL: 0
; 0000 003E 
; 0000 003F // Disable the autocalibration of the internal 2 MHz RC oscillator
; 0000 0040 DFLLRC2M.CTRL&= ~DFLL_ENABLE_bm;
;PCODE: $00000014 VOL: 1
;PCODE: $00000015 VOL: 0
;PCODE: $00000016 VOL: 1
; 0000 0041 
; 0000 0042 // Wait for the internal 2 MHz RC oscillator to stabilize
; 0000 0043 while ((OSC.STATUS & OSC_RC2MRDY_bm)==0);
;PCODE: $00000017 VOL: 0
;PCODE: $00000018 VOL: 1
;PCODE: $00000019 VOL: 0
;PCODE: $0000001A VOL: 0
;PCODE: $0000001B VOL: 0
;PCODE: $0000001C VOL: 0
; 0000 0044 
; 0000 0045 // Select the system clock source: 2 MHz Internal RC Osc.
; 0000 0046 n=(CLK.CTRL & (~CLK_SCLKSEL_gm)) | CLK_SCLKSEL_RC2M_gc;
;PCODE: $0000001D VOL: 1
;PCODE: $0000001E VOL: 0
;PCODE: $0000001F VOL: 0
;PCODE: $00000020 VOL: 0
; 0000 0047 CCP=CCP_IOREG_gc;
;PCODE: $00000021 VOL: 0
;PCODE: $00000022 VOL: 0
; 0000 0048 CLK.CTRL=n;
;PCODE: $00000023 VOL: 1
;PCODE: $00000024 VOL: 0
; 0000 0049 
; 0000 004A // Disable the unused oscillators: 32 MHz, 32 kHz, external clock/crystal oscillator, PLL
; 0000 004B OSC.CTRL&= ~(OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
;PCODE: $00000025 VOL: 1
;PCODE: $00000026 VOL: 0
;PCODE: $00000027 VOL: 1
; 0000 004C 
; 0000 004D // Peripheral Clock output: Disabled
; 0000 004E PORTCFG.CLKEVOUT=(PORTCFG.CLKEVOUT & (~PORTCFG_CLKOUT_gm)) | PORTCFG_CLKOUT_OFF_gc;
;PCODE: $00000028 VOL: 1
;PCODE: $00000029 VOL: 0
;PCODE: $0000002A VOL: 0
;PCODE: $0000002B VOL: 1
; 0000 004F 
; 0000 0050 // Restore interrupts enabled/disabled state
; 0000 0051 SREG=s;
;PCODE: $0000002C VOL: 0
;PCODE: $0000002D VOL: 0
; 0000 0052 // Restore optimization for size if needed
; 0000 0053 #pragma optsize_default
; 0000 0054 }
;PCODE: $0000002E VOL: 0
;PCODE: $0000002F VOL: 0
;PCODE: $00000030 VOL: 0
;
;// Ports initialization
;void ports_init(void)
; 0000 0058 {
;PCODE: $00000031 VOL: 0
;PCODE: $00000032 VOL: 0
; 0000 0059 // PORTA initialization
; 0000 005A // OUT register
; 0000 005B PORTA.OUT=0x00;
;PCODE: $00000033 VOL: 0
;PCODE: $00000034 VOL: 1
; 0000 005C // Bit0: Input
; 0000 005D // Bit1: Input
; 0000 005E // Bit2: Input
; 0000 005F // Bit3: Input
; 0000 0060 // Bit4: Input
; 0000 0061 // Bit5: Input
; 0000 0062 // Bit6: Input
; 0000 0063 // Bit7: Input
; 0000 0064 PORTA.DIR=0x00;
;PCODE: $00000035 VOL: 0
;PCODE: $00000036 VOL: 1
; 0000 0065 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0066 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0067 // Bit0 inverted: Off
; 0000 0068 // Bit0 slew rate limitation: Off
; 0000 0069 PORTA.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000037 VOL: 0
;PCODE: $00000038 VOL: 1
; 0000 006A // Bit1 Output/Pull configuration: Totempole/No
; 0000 006B // Bit1 Input/Sense configuration: Sense both edges
; 0000 006C // Bit1 inverted: Off
; 0000 006D // Bit1 slew rate limitation: Off
; 0000 006E PORTA.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000039 VOL: 0
;PCODE: $0000003A VOL: 1
; 0000 006F // Bit2 Output/Pull configuration: Totempole/No
; 0000 0070 // Bit2 Input/Sense configuration: Sense both edges
; 0000 0071 // Bit2 inverted: Off
; 0000 0072 // Bit2 slew rate limitation: Off
; 0000 0073 PORTA.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000003B VOL: 0
;PCODE: $0000003C VOL: 1
; 0000 0074 // Bit3 Output/Pull configuration: Totempole/No
; 0000 0075 // Bit3 Input/Sense configuration: Sense both edges
; 0000 0076 // Bit3 inverted: Off
; 0000 0077 // Bit3 slew rate limitation: Off
; 0000 0078 PORTA.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000003D VOL: 0
;PCODE: $0000003E VOL: 1
; 0000 0079 // Bit4 Output/Pull configuration: Totempole/No
; 0000 007A // Bit4 Input/Sense configuration: Sense both edges
; 0000 007B // Bit4 inverted: Off
; 0000 007C // Bit4 slew rate limitation: Off
; 0000 007D PORTA.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000003F VOL: 0
;PCODE: $00000040 VOL: 1
; 0000 007E // Bit5 Output/Pull configuration: Totempole/No
; 0000 007F // Bit5 Input/Sense configuration: Sense both edges
; 0000 0080 // Bit5 inverted: Off
; 0000 0081 // Bit5 slew rate limitation: Off
; 0000 0082 PORTA.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000041 VOL: 0
;PCODE: $00000042 VOL: 1
; 0000 0083 // Bit6 Output/Pull configuration: Totempole/No
; 0000 0084 // Bit6 Input/Sense configuration: Sense both edges
; 0000 0085 // Bit6 inverted: Off
; 0000 0086 // Bit6 slew rate limitation: Off
; 0000 0087 PORTA.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000043 VOL: 0
;PCODE: $00000044 VOL: 1
; 0000 0088 // Bit7 Output/Pull configuration: Totempole/No
; 0000 0089 // Bit7 Input/Sense configuration: Sense both edges
; 0000 008A // Bit7 inverted: Off
; 0000 008B // Bit7 slew rate limitation: Off
; 0000 008C PORTA.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000045 VOL: 0
;PCODE: $00000046 VOL: 1
; 0000 008D // Interrupt 0 level: Disabled
; 0000 008E // Interrupt 1 level: Disabled
; 0000 008F PORTA.INTCTRL=(PORTA.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 0090 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000047 VOL: 1
;PCODE: $00000048 VOL: 0
;PCODE: $00000049 VOL: 0
;PCODE: $0000004A VOL: 0
;PCODE: $0000004B VOL: 1
; 0000 0091 // Bit0 pin change interrupt 0: Off
; 0000 0092 // Bit1 pin change interrupt 0: Off
; 0000 0093 // Bit2 pin change interrupt 0: Off
; 0000 0094 // Bit3 pin change interrupt 0: Off
; 0000 0095 // Bit4 pin change interrupt 0: Off
; 0000 0096 // Bit5 pin change interrupt 0: Off
; 0000 0097 // Bit6 pin change interrupt 0: Off
; 0000 0098 // Bit7 pin change interrupt 0: Off
; 0000 0099 PORTA.INT0MASK=0x00;
;PCODE: $0000004C VOL: 0
;PCODE: $0000004D VOL: 1
; 0000 009A // Bit0 pin change interrupt 1: Off
; 0000 009B // Bit1 pin change interrupt 1: Off
; 0000 009C // Bit2 pin change interrupt 1: Off
; 0000 009D // Bit3 pin change interrupt 1: Off
; 0000 009E // Bit4 pin change interrupt 1: Off
; 0000 009F // Bit5 pin change interrupt 1: Off
; 0000 00A0 // Bit6 pin change interrupt 1: Off
; 0000 00A1 // Bit7 pin change interrupt 1: Off
; 0000 00A2 PORTA.INT1MASK=0x00;
;PCODE: $0000004E VOL: 0
;PCODE: $0000004F VOL: 1
; 0000 00A3 
; 0000 00A4 // PORTB initialization
; 0000 00A5 // OUT register
; 0000 00A6 PORTB.OUT=0x00;
;PCODE: $00000050 VOL: 0
;PCODE: $00000051 VOL: 1
; 0000 00A7 // Bit0: Input
; 0000 00A8 // Bit1: Input
; 0000 00A9 // Bit2: Input
; 0000 00AA // Bit3: Input
; 0000 00AB // Bit4: Input
; 0000 00AC // Bit5: Input
; 0000 00AD // Bit6: Input
; 0000 00AE // Bit7: Input
; 0000 00AF PORTB.DIR=0x00;
;PCODE: $00000052 VOL: 0
;PCODE: $00000053 VOL: 1
; 0000 00B0 // Bit0 Output/Pull configuration: Totempole/No
; 0000 00B1 // Bit0 Input/Sense configuration: Sense both edges
; 0000 00B2 // Bit0 inverted: Off
; 0000 00B3 // Bit0 slew rate limitation: Off
; 0000 00B4 PORTB.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000054 VOL: 0
;PCODE: $00000055 VOL: 1
; 0000 00B5 // Bit1 Output/Pull configuration: Totempole/No
; 0000 00B6 // Bit1 Input/Sense configuration: Sense both edges
; 0000 00B7 // Bit1 inverted: Off
; 0000 00B8 // Bit1 slew rate limitation: Off
; 0000 00B9 PORTB.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000056 VOL: 0
;PCODE: $00000057 VOL: 1
; 0000 00BA // Bit2 Output/Pull configuration: Totempole/No
; 0000 00BB // Bit2 Input/Sense configuration: Sense both edges
; 0000 00BC // Bit2 inverted: Off
; 0000 00BD // Bit2 slew rate limitation: Off
; 0000 00BE PORTB.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000058 VOL: 0
;PCODE: $00000059 VOL: 1
; 0000 00BF // Bit3 Output/Pull configuration: Totempole/No
; 0000 00C0 // Bit3 Input/Sense configuration: Sense both edges
; 0000 00C1 // Bit3 inverted: Off
; 0000 00C2 // Bit3 slew rate limitation: Off
; 0000 00C3 PORTB.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000005A VOL: 0
;PCODE: $0000005B VOL: 1
; 0000 00C4 // Bit4 Output/Pull configuration: Totempole/No
; 0000 00C5 // Bit4 Input/Sense configuration: Sense both edges
; 0000 00C6 // Bit4 inverted: Off
; 0000 00C7 // Bit4 slew rate limitation: Off
; 0000 00C8 PORTB.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000005C VOL: 0
;PCODE: $0000005D VOL: 1
; 0000 00C9 // Bit5 Output/Pull configuration: Totempole/No
; 0000 00CA // Bit5 Input/Sense configuration: Sense both edges
; 0000 00CB // Bit5 inverted: Off
; 0000 00CC // Bit5 slew rate limitation: Off
; 0000 00CD PORTB.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000005E VOL: 0
;PCODE: $0000005F VOL: 1
; 0000 00CE // Bit6 Output/Pull configuration: Totempole/No
; 0000 00CF // Bit6 Input/Sense configuration: Sense both edges
; 0000 00D0 // Bit6 inverted: Off
; 0000 00D1 // Bit6 slew rate limitation: Off
; 0000 00D2 PORTB.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000060 VOL: 0
;PCODE: $00000061 VOL: 1
; 0000 00D3 // Bit7 Output/Pull configuration: Totempole/No
; 0000 00D4 // Bit7 Input/Sense configuration: Sense both edges
; 0000 00D5 // Bit7 inverted: Off
; 0000 00D6 // Bit7 slew rate limitation: Off
; 0000 00D7 PORTB.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000062 VOL: 0
;PCODE: $00000063 VOL: 1
; 0000 00D8 // Interrupt 0 level: Disabled
; 0000 00D9 // Interrupt 1 level: Disabled
; 0000 00DA PORTB.INTCTRL=(PORTB.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 00DB 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000064 VOL: 1
;PCODE: $00000065 VOL: 0
;PCODE: $00000066 VOL: 0
;PCODE: $00000067 VOL: 0
;PCODE: $00000068 VOL: 1
; 0000 00DC // Bit0 pin change interrupt 0: Off
; 0000 00DD // Bit1 pin change interrupt 0: Off
; 0000 00DE // Bit2 pin change interrupt 0: Off
; 0000 00DF // Bit3 pin change interrupt 0: Off
; 0000 00E0 // Bit4 pin change interrupt 0: Off
; 0000 00E1 // Bit5 pin change interrupt 0: Off
; 0000 00E2 // Bit6 pin change interrupt 0: Off
; 0000 00E3 // Bit7 pin change interrupt 0: Off
; 0000 00E4 PORTB.INT0MASK=0x00;
;PCODE: $00000069 VOL: 0
;PCODE: $0000006A VOL: 1
; 0000 00E5 // Bit0 pin change interrupt 1: Off
; 0000 00E6 // Bit1 pin change interrupt 1: Off
; 0000 00E7 // Bit2 pin change interrupt 1: Off
; 0000 00E8 // Bit3 pin change interrupt 1: Off
; 0000 00E9 // Bit4 pin change interrupt 1: Off
; 0000 00EA // Bit5 pin change interrupt 1: Off
; 0000 00EB // Bit6 pin change interrupt 1: Off
; 0000 00EC // Bit7 pin change interrupt 1: Off
; 0000 00ED PORTB.INT1MASK=0x00;
;PCODE: $0000006B VOL: 0
;PCODE: $0000006C VOL: 1
; 0000 00EE 
; 0000 00EF // PORTC initialization
; 0000 00F0 // OUT register
; 0000 00F1 PORTC.OUT=0x08;
;PCODE: $0000006D VOL: 0
;PCODE: $0000006E VOL: 1
; 0000 00F2 // Bit0: Input
; 0000 00F3 // Bit1: Input
; 0000 00F4 // Bit2: Input
; 0000 00F5 // Bit3: Output
; 0000 00F6 // Bit4: Input
; 0000 00F7 // Bit5: Input
; 0000 00F8 // Bit6: Input
; 0000 00F9 // Bit7: Input
; 0000 00FA PORTC.DIR=0x08;
;PCODE: $0000006F VOL: 0
;PCODE: $00000070 VOL: 1
; 0000 00FB // Bit0 Output/Pull configuration: Totempole/No
; 0000 00FC // Bit0 Input/Sense configuration: Sense both edges
; 0000 00FD // Bit0 inverted: Off
; 0000 00FE // Bit0 slew rate limitation: Off
; 0000 00FF PORTC.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000071 VOL: 0
;PCODE: $00000072 VOL: 1
; 0000 0100 // Bit1 Output/Pull configuration: Totempole/No
; 0000 0101 // Bit1 Input/Sense configuration: Sense both edges
; 0000 0102 // Bit1 inverted: Off
; 0000 0103 // Bit1 slew rate limitation: Off
; 0000 0104 PORTC.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000073 VOL: 0
;PCODE: $00000074 VOL: 1
; 0000 0105 // Bit2 Output/Pull configuration: Totempole/No
; 0000 0106 // Bit2 Input/Sense configuration: Sense both edges
; 0000 0107 // Bit2 inverted: Off
; 0000 0108 // Bit2 slew rate limitation: Off
; 0000 0109 PORTC.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000075 VOL: 0
;PCODE: $00000076 VOL: 1
; 0000 010A // Bit3 Output/Pull configuration: Totempole/No
; 0000 010B // Bit3 Input/Sense configuration: Sense both edges
; 0000 010C // Bit3 inverted: Off
; 0000 010D // Bit3 slew rate limitation: Off
; 0000 010E PORTC.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000077 VOL: 0
;PCODE: $00000078 VOL: 1
; 0000 010F // Bit4 Output/Pull configuration: Totempole/No
; 0000 0110 // Bit4 Input/Sense configuration: Sense both edges
; 0000 0111 // Bit4 inverted: Off
; 0000 0112 // Bit4 slew rate limitation: Off
; 0000 0113 PORTC.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000079 VOL: 0
;PCODE: $0000007A VOL: 1
; 0000 0114 // Bit5 Output/Pull configuration: Totempole/No
; 0000 0115 // Bit5 Input/Sense configuration: Sense both edges
; 0000 0116 // Bit5 inverted: Off
; 0000 0117 // Bit5 slew rate limitation: Off
; 0000 0118 PORTC.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000007B VOL: 0
;PCODE: $0000007C VOL: 1
; 0000 0119 // Bit6 Output/Pull configuration: Totempole/No
; 0000 011A // Bit6 Input/Sense configuration: Sense both edges
; 0000 011B // Bit6 inverted: Off
; 0000 011C // Bit6 slew rate limitation: Off
; 0000 011D PORTC.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000007D VOL: 0
;PCODE: $0000007E VOL: 1
; 0000 011E // Bit7 Output/Pull configuration: Totempole/No
; 0000 011F // Bit7 Input/Sense configuration: Sense both edges
; 0000 0120 // Bit7 inverted: Off
; 0000 0121 // Bit7 slew rate limitation: Off
; 0000 0122 PORTC.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000007F VOL: 0
;PCODE: $00000080 VOL: 1
; 0000 0123 // Interrupt 0 level: Disabled
; 0000 0124 // Interrupt 1 level: Disabled
; 0000 0125 PORTC.INTCTRL=(PORTC.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 0126 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000081 VOL: 1
;PCODE: $00000082 VOL: 0
;PCODE: $00000083 VOL: 0
;PCODE: $00000084 VOL: 0
;PCODE: $00000085 VOL: 1
; 0000 0127 // Bit0 pin change interrupt 0: Off
; 0000 0128 // Bit1 pin change interrupt 0: Off
; 0000 0129 // Bit2 pin change interrupt 0: Off
; 0000 012A // Bit3 pin change interrupt 0: Off
; 0000 012B // Bit4 pin change interrupt 0: Off
; 0000 012C // Bit5 pin change interrupt 0: Off
; 0000 012D // Bit6 pin change interrupt 0: Off
; 0000 012E // Bit7 pin change interrupt 0: Off
; 0000 012F PORTC.INT0MASK=0x00;
;PCODE: $00000086 VOL: 0
;PCODE: $00000087 VOL: 1
; 0000 0130 // Bit0 pin change interrupt 1: Off
; 0000 0131 // Bit1 pin change interrupt 1: Off
; 0000 0132 // Bit2 pin change interrupt 1: Off
; 0000 0133 // Bit3 pin change interrupt 1: Off
; 0000 0134 // Bit4 pin change interrupt 1: Off
; 0000 0135 // Bit5 pin change interrupt 1: Off
; 0000 0136 // Bit6 pin change interrupt 1: Off
; 0000 0137 // Bit7 pin change interrupt 1: Off
; 0000 0138 PORTC.INT1MASK=0x00;
;PCODE: $00000088 VOL: 0
;PCODE: $00000089 VOL: 1
; 0000 0139 
; 0000 013A // PORTD initialization
; 0000 013B // OUT register
; 0000 013C PORTD.OUT=0x08;
;PCODE: $0000008A VOL: 0
;PCODE: $0000008B VOL: 1
; 0000 013D // Bit0: Input
; 0000 013E // Bit1: Input
; 0000 013F // Bit2: Input
; 0000 0140 // Bit3: Output
; 0000 0141 // Bit4: Input
; 0000 0142 // Bit5: Input
; 0000 0143 // Bit6: Input
; 0000 0144 // Bit7: Input
; 0000 0145 PORTD.DIR=0x08;
;PCODE: $0000008C VOL: 0
;PCODE: $0000008D VOL: 1
; 0000 0146 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0147 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0148 // Bit0 inverted: Off
; 0000 0149 // Bit0 slew rate limitation: Off
; 0000 014A PORTD.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000008E VOL: 0
;PCODE: $0000008F VOL: 1
; 0000 014B // Bit1 Output/Pull configuration: Totempole/No
; 0000 014C // Bit1 Input/Sense configuration: Sense both edges
; 0000 014D // Bit1 inverted: Off
; 0000 014E // Bit1 slew rate limitation: Off
; 0000 014F PORTD.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000090 VOL: 0
;PCODE: $00000091 VOL: 1
; 0000 0150 // Bit2 Output/Pull configuration: Totempole/No
; 0000 0151 // Bit2 Input/Sense configuration: Sense both edges
; 0000 0152 // Bit2 inverted: Off
; 0000 0153 // Bit2 slew rate limitation: Off
; 0000 0154 PORTD.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000092 VOL: 0
;PCODE: $00000093 VOL: 1
; 0000 0155 // Bit3 Output/Pull configuration: Totempole/No
; 0000 0156 // Bit3 Input/Sense configuration: Sense both edges
; 0000 0157 // Bit3 inverted: Off
; 0000 0158 // Bit3 slew rate limitation: Off
; 0000 0159 PORTD.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000094 VOL: 0
;PCODE: $00000095 VOL: 1
; 0000 015A // Bit4 Output/Pull configuration: Totempole/No
; 0000 015B // Bit4 Input/Sense configuration: Sense both edges
; 0000 015C // Bit4 inverted: Off
; 0000 015D // Bit4 slew rate limitation: Off
; 0000 015E PORTD.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000096 VOL: 0
;PCODE: $00000097 VOL: 1
; 0000 015F // Bit5 Output/Pull configuration: Totempole/No
; 0000 0160 // Bit5 Input/Sense configuration: Sense both edges
; 0000 0161 // Bit5 inverted: Off
; 0000 0162 // Bit5 slew rate limitation: Off
; 0000 0163 PORTD.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000098 VOL: 0
;PCODE: $00000099 VOL: 1
; 0000 0164 // Bit6 Output/Pull configuration: Totempole/No
; 0000 0165 // Bit6 Input/Sense configuration: Sense both edges
; 0000 0166 // Bit6 inverted: Off
; 0000 0167 // Bit6 slew rate limitation: Off
; 0000 0168 PORTD.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000009A VOL: 0
;PCODE: $0000009B VOL: 1
; 0000 0169 // Bit7 Output/Pull configuration: Totempole/No
; 0000 016A // Bit7 Input/Sense configuration: Sense both edges
; 0000 016B // Bit7 inverted: Off
; 0000 016C // Bit7 slew rate limitation: Off
; 0000 016D PORTD.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000009C VOL: 0
;PCODE: $0000009D VOL: 1
; 0000 016E // Interrupt 0 level: Disabled
; 0000 016F // Interrupt 1 level: Disabled
; 0000 0170 PORTD.INTCTRL=(PORTD.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 0171 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $0000009E VOL: 1
;PCODE: $0000009F VOL: 0
;PCODE: $000000A0 VOL: 0
;PCODE: $000000A1 VOL: 0
;PCODE: $000000A2 VOL: 1
; 0000 0172 // Bit0 pin change interrupt 0: Off
; 0000 0173 // Bit1 pin change interrupt 0: Off
; 0000 0174 // Bit2 pin change interrupt 0: Off
; 0000 0175 // Bit3 pin change interrupt 0: Off
; 0000 0176 // Bit4 pin change interrupt 0: Off
; 0000 0177 // Bit5 pin change interrupt 0: Off
; 0000 0178 // Bit6 pin change interrupt 0: Off
; 0000 0179 // Bit7 pin change interrupt 0: Off
; 0000 017A PORTD.INT0MASK=0x00;
;PCODE: $000000A3 VOL: 0
;PCODE: $000000A4 VOL: 1
; 0000 017B // Bit0 pin change interrupt 1: Off
; 0000 017C // Bit1 pin change interrupt 1: Off
; 0000 017D // Bit2 pin change interrupt 1: Off
; 0000 017E // Bit3 pin change interrupt 1: Off
; 0000 017F // Bit4 pin change interrupt 1: Off
; 0000 0180 // Bit5 pin change interrupt 1: Off
; 0000 0181 // Bit6 pin change interrupt 1: Off
; 0000 0182 // Bit7 pin change interrupt 1: Off
; 0000 0183 PORTD.INT1MASK=0x00;
;PCODE: $000000A5 VOL: 0
;PCODE: $000000A6 VOL: 1
; 0000 0184 
; 0000 0185 // PORTE initialization
; 0000 0186 // OUT register
; 0000 0187 PORTE.OUT=0x00;
;PCODE: $000000A7 VOL: 0
;PCODE: $000000A8 VOL: 1
; 0000 0188 // Bit0: Input
; 0000 0189 // Bit1: Input
; 0000 018A // Bit2: Input
; 0000 018B // Bit3: Input
; 0000 018C // Bit4: Input
; 0000 018D // Bit5: Input
; 0000 018E // Bit6: Input
; 0000 018F // Bit7: Input
; 0000 0190 PORTE.DIR=0x00;
;PCODE: $000000A9 VOL: 0
;PCODE: $000000AA VOL: 1
; 0000 0191 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0192 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0193 // Bit0 inverted: Off
; 0000 0194 // Bit0 slew rate limitation: Off
; 0000 0195 PORTE.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000AB VOL: 0
;PCODE: $000000AC VOL: 1
; 0000 0196 // Bit1 Output/Pull configuration: Totempole/No
; 0000 0197 // Bit1 Input/Sense configuration: Sense both edges
; 0000 0198 // Bit1 inverted: Off
; 0000 0199 // Bit1 slew rate limitation: Off
; 0000 019A PORTE.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000AD VOL: 0
;PCODE: $000000AE VOL: 1
; 0000 019B // Bit2 Output/Pull configuration: Totempole/No
; 0000 019C // Bit2 Input/Sense configuration: Sense both edges
; 0000 019D // Bit2 inverted: Off
; 0000 019E // Bit2 slew rate limitation: Off
; 0000 019F PORTE.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000AF VOL: 0
;PCODE: $000000B0 VOL: 1
; 0000 01A0 // Bit3 Output/Pull configuration: Totempole/No
; 0000 01A1 // Bit3 Input/Sense configuration: Sense both edges
; 0000 01A2 // Bit3 inverted: Off
; 0000 01A3 // Bit3 slew rate limitation: Off
; 0000 01A4 PORTE.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000B1 VOL: 0
;PCODE: $000000B2 VOL: 1
; 0000 01A5 // Bit4 Output/Pull configuration: Totempole/No
; 0000 01A6 // Bit4 Input/Sense configuration: Sense both edges
; 0000 01A7 // Bit4 inverted: Off
; 0000 01A8 // Bit4 slew rate limitation: Off
; 0000 01A9 PORTE.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000B3 VOL: 0
;PCODE: $000000B4 VOL: 1
; 0000 01AA // Bit5 Output/Pull configuration: Totempole/No
; 0000 01AB // Bit5 Input/Sense configuration: Sense both edges
; 0000 01AC // Bit5 inverted: Off
; 0000 01AD // Bit5 slew rate limitation: Off
; 0000 01AE PORTE.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000B5 VOL: 0
;PCODE: $000000B6 VOL: 1
; 0000 01AF // Bit6 Output/Pull configuration: Totempole/No
; 0000 01B0 // Bit6 Input/Sense configuration: Sense both edges
; 0000 01B1 // Bit6 inverted: Off
; 0000 01B2 // Bit6 slew rate limitation: Off
; 0000 01B3 PORTE.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000B7 VOL: 0
;PCODE: $000000B8 VOL: 1
; 0000 01B4 // Bit7 Output/Pull configuration: Totempole/No
; 0000 01B5 // Bit7 Input/Sense configuration: Sense both edges
; 0000 01B6 // Bit7 inverted: Off
; 0000 01B7 // Bit7 slew rate limitation: Off
; 0000 01B8 PORTE.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000B9 VOL: 0
;PCODE: $000000BA VOL: 1
; 0000 01B9 // Interrupt 0 level: Disabled
; 0000 01BA // Interrupt 1 level: Disabled
; 0000 01BB PORTE.INTCTRL=(PORTE.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 01BC 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $000000BB VOL: 1
;PCODE: $000000BC VOL: 0
;PCODE: $000000BD VOL: 0
;PCODE: $000000BE VOL: 0
;PCODE: $000000BF VOL: 1
; 0000 01BD // Bit0 pin change interrupt 0: Off
; 0000 01BE // Bit1 pin change interrupt 0: Off
; 0000 01BF // Bit2 pin change interrupt 0: Off
; 0000 01C0 // Bit3 pin change interrupt 0: Off
; 0000 01C1 // Bit4 pin change interrupt 0: Off
; 0000 01C2 // Bit5 pin change interrupt 0: Off
; 0000 01C3 // Bit6 pin change interrupt 0: Off
; 0000 01C4 // Bit7 pin change interrupt 0: Off
; 0000 01C5 PORTE.INT0MASK=0x00;
;PCODE: $000000C0 VOL: 0
;PCODE: $000000C1 VOL: 1
; 0000 01C6 // Bit0 pin change interrupt 1: Off
; 0000 01C7 // Bit1 pin change interrupt 1: Off
; 0000 01C8 // Bit2 pin change interrupt 1: Off
; 0000 01C9 // Bit3 pin change interrupt 1: Off
; 0000 01CA // Bit4 pin change interrupt 1: Off
; 0000 01CB // Bit5 pin change interrupt 1: Off
; 0000 01CC // Bit6 pin change interrupt 1: Off
; 0000 01CD // Bit7 pin change interrupt 1: Off
; 0000 01CE PORTE.INT1MASK=0x00;
;PCODE: $000000C2 VOL: 0
;PCODE: $000000C3 VOL: 1
; 0000 01CF 
; 0000 01D0 // PORTF initialization
; 0000 01D1 // OUT register
; 0000 01D2 PORTF.OUT=0x00;
;PCODE: $000000C4 VOL: 0
;PCODE: $000000C5 VOL: 1
; 0000 01D3 // Bit0: Input
; 0000 01D4 // Bit1: Input
; 0000 01D5 // Bit2: Input
; 0000 01D6 // Bit3: Input
; 0000 01D7 // Bit4: Input
; 0000 01D8 // Bit5: Input
; 0000 01D9 // Bit6: Input
; 0000 01DA // Bit7: Input
; 0000 01DB PORTF.DIR=0x00;
;PCODE: $000000C6 VOL: 0
;PCODE: $000000C7 VOL: 1
; 0000 01DC // Bit0 Output/Pull configuration: Totempole/No
; 0000 01DD // Bit0 Input/Sense configuration: Sense both edges
; 0000 01DE // Bit0 inverted: Off
; 0000 01DF // Bit0 slew rate limitation: Off
; 0000 01E0 PORTF.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000C8 VOL: 0
;PCODE: $000000C9 VOL: 1
; 0000 01E1 // Bit1 Output/Pull configuration: Totempole/No
; 0000 01E2 // Bit1 Input/Sense configuration: Sense both edges
; 0000 01E3 // Bit1 inverted: Off
; 0000 01E4 // Bit1 slew rate limitation: Off
; 0000 01E5 PORTF.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000CA VOL: 0
;PCODE: $000000CB VOL: 1
; 0000 01E6 // Bit2 Output/Pull configuration: Totempole/No
; 0000 01E7 // Bit2 Input/Sense configuration: Sense both edges
; 0000 01E8 // Bit2 inverted: Off
; 0000 01E9 // Bit2 slew rate limitation: Off
; 0000 01EA PORTF.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000CC VOL: 0
;PCODE: $000000CD VOL: 1
; 0000 01EB // Bit3 Output/Pull configuration: Totempole/No
; 0000 01EC // Bit3 Input/Sense configuration: Sense both edges
; 0000 01ED // Bit3 inverted: Off
; 0000 01EE // Bit3 slew rate limitation: Off
; 0000 01EF PORTF.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000CE VOL: 0
;PCODE: $000000CF VOL: 1
; 0000 01F0 // Bit4 Output/Pull configuration: Totempole/No
; 0000 01F1 // Bit4 Input/Sense configuration: Sense both edges
; 0000 01F2 // Bit4 inverted: Off
; 0000 01F3 // Bit4 slew rate limitation: Off
; 0000 01F4 PORTF.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000D0 VOL: 0
;PCODE: $000000D1 VOL: 1
; 0000 01F5 // Bit5 Output/Pull configuration: Totempole/No
; 0000 01F6 // Bit5 Input/Sense configuration: Sense both edges
; 0000 01F7 // Bit5 inverted: Off
; 0000 01F8 // Bit5 slew rate limitation: Off
; 0000 01F9 PORTF.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000D2 VOL: 0
;PCODE: $000000D3 VOL: 1
; 0000 01FA // Bit6 Output/Pull configuration: Totempole/No
; 0000 01FB // Bit6 Input/Sense configuration: Sense both edges
; 0000 01FC // Bit6 inverted: Off
; 0000 01FD // Bit6 slew rate limitation: Off
; 0000 01FE PORTF.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000D4 VOL: 0
;PCODE: $000000D5 VOL: 1
; 0000 01FF // Bit7 Output/Pull configuration: Totempole/No
; 0000 0200 // Bit7 Input/Sense configuration: Sense both edges
; 0000 0201 // Bit7 inverted: Off
; 0000 0202 // Bit7 slew rate limitation: Off
; 0000 0203 PORTF.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000D6 VOL: 0
;PCODE: $000000D7 VOL: 1
; 0000 0204 // Interrupt 0 level: Disabled
; 0000 0205 // Interrupt 1 level: Disabled
; 0000 0206 PORTF.INTCTRL=(PORTF.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 0207 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $000000D8 VOL: 1
;PCODE: $000000D9 VOL: 0
;PCODE: $000000DA VOL: 0
;PCODE: $000000DB VOL: 0
;PCODE: $000000DC VOL: 1
; 0000 0208 // Bit0 pin change interrupt 0: Off
; 0000 0209 // Bit1 pin change interrupt 0: Off
; 0000 020A // Bit2 pin change interrupt 0: Off
; 0000 020B // Bit3 pin change interrupt 0: Off
; 0000 020C // Bit4 pin change interrupt 0: Off
; 0000 020D // Bit5 pin change interrupt 0: Off
; 0000 020E // Bit6 pin change interrupt 0: Off
; 0000 020F // Bit7 pin change interrupt 0: Off
; 0000 0210 PORTF.INT0MASK=0x00;
;PCODE: $000000DD VOL: 0
;PCODE: $000000DE VOL: 1
; 0000 0211 // Bit0 pin change interrupt 1: Off
; 0000 0212 // Bit1 pin change interrupt 1: Off
; 0000 0213 // Bit2 pin change interrupt 1: Off
; 0000 0214 // Bit3 pin change interrupt 1: Off
; 0000 0215 // Bit4 pin change interrupt 1: Off
; 0000 0216 // Bit5 pin change interrupt 1: Off
; 0000 0217 // Bit6 pin change interrupt 1: Off
; 0000 0218 // Bit7 pin change interrupt 1: Off
; 0000 0219 PORTF.INT1MASK=0x00;
;PCODE: $000000DF VOL: 0
;PCODE: $000000E0 VOL: 1
; 0000 021A 
; 0000 021B // PORTH initialization
; 0000 021C // OUT register
; 0000 021D PORTH.OUT=0x00;
;PCODE: $000000E1 VOL: 0
;PCODE: $000000E2 VOL: 1
; 0000 021E // Bit0: Input
; 0000 021F // Bit1: Input
; 0000 0220 // Bit2: Input
; 0000 0221 // Bit3: Input
; 0000 0222 // Bit4: Input
; 0000 0223 // Bit5: Input
; 0000 0224 // Bit6: Input
; 0000 0225 // Bit7: Input
; 0000 0226 PORTH.DIR=0x00;
;PCODE: $000000E3 VOL: 0
;PCODE: $000000E4 VOL: 1
; 0000 0227 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0228 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0229 // Bit0 inverted: Off
; 0000 022A // Bit0 slew rate limitation: Off
; 0000 022B PORTH.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000E5 VOL: 0
;PCODE: $000000E6 VOL: 1
; 0000 022C // Bit1 Output/Pull configuration: Totempole/No
; 0000 022D // Bit1 Input/Sense configuration: Sense both edges
; 0000 022E // Bit1 inverted: Off
; 0000 022F // Bit1 slew rate limitation: Off
; 0000 0230 PORTH.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000E7 VOL: 0
;PCODE: $000000E8 VOL: 1
; 0000 0231 // Bit2 Output/Pull configuration: Totempole/No
; 0000 0232 // Bit2 Input/Sense configuration: Sense both edges
; 0000 0233 // Bit2 inverted: Off
; 0000 0234 // Bit2 slew rate limitation: Off
; 0000 0235 PORTH.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000E9 VOL: 0
;PCODE: $000000EA VOL: 1
; 0000 0236 // Bit3 Output/Pull configuration: Totempole/No
; 0000 0237 // Bit3 Input/Sense configuration: Sense both edges
; 0000 0238 // Bit3 inverted: Off
; 0000 0239 // Bit3 slew rate limitation: Off
; 0000 023A PORTH.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000EB VOL: 0
;PCODE: $000000EC VOL: 1
; 0000 023B // Bit4 Output/Pull configuration: Totempole/No
; 0000 023C // Bit4 Input/Sense configuration: Sense both edges
; 0000 023D // Bit4 inverted: Off
; 0000 023E // Bit4 slew rate limitation: Off
; 0000 023F PORTH.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000ED VOL: 0
;PCODE: $000000EE VOL: 1
; 0000 0240 // Bit5 Output/Pull configuration: Totempole/No
; 0000 0241 // Bit5 Input/Sense configuration: Sense both edges
; 0000 0242 // Bit5 inverted: Off
; 0000 0243 // Bit5 slew rate limitation: Off
; 0000 0244 PORTH.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000EF VOL: 0
;PCODE: $000000F0 VOL: 1
; 0000 0245 // Bit6 Output/Pull configuration: Totempole/No
; 0000 0246 // Bit6 Input/Sense configuration: Sense both edges
; 0000 0247 // Bit6 inverted: Off
; 0000 0248 // Bit6 slew rate limitation: Off
; 0000 0249 PORTH.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000F1 VOL: 0
;PCODE: $000000F2 VOL: 1
; 0000 024A // Bit7 Output/Pull configuration: Totempole/No
; 0000 024B // Bit7 Input/Sense configuration: Sense both edges
; 0000 024C // Bit7 inverted: Off
; 0000 024D // Bit7 slew rate limitation: Off
; 0000 024E PORTH.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $000000F3 VOL: 0
;PCODE: $000000F4 VOL: 1
; 0000 024F // Interrupt 0 level: Disabled
; 0000 0250 // Interrupt 1 level: Disabled
; 0000 0251 PORTH.INTCTRL=(PORTH.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 0252 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $000000F5 VOL: 1
;PCODE: $000000F6 VOL: 0
;PCODE: $000000F7 VOL: 0
;PCODE: $000000F8 VOL: 0
;PCODE: $000000F9 VOL: 1
; 0000 0253 // Bit0 pin change interrupt 0: Off
; 0000 0254 // Bit1 pin change interrupt 0: Off
; 0000 0255 // Bit2 pin change interrupt 0: Off
; 0000 0256 // Bit3 pin change interrupt 0: Off
; 0000 0257 // Bit4 pin change interrupt 0: Off
; 0000 0258 // Bit5 pin change interrupt 0: Off
; 0000 0259 // Bit6 pin change interrupt 0: Off
; 0000 025A // Bit7 pin change interrupt 0: Off
; 0000 025B PORTH.INT0MASK=0x00;
;PCODE: $000000FA VOL: 0
;PCODE: $000000FB VOL: 1
; 0000 025C // Bit0 pin change interrupt 1: Off
; 0000 025D // Bit1 pin change interrupt 1: Off
; 0000 025E // Bit2 pin change interrupt 1: Off
; 0000 025F // Bit3 pin change interrupt 1: Off
; 0000 0260 // Bit4 pin change interrupt 1: Off
; 0000 0261 // Bit5 pin change interrupt 1: Off
; 0000 0262 // Bit6 pin change interrupt 1: Off
; 0000 0263 // Bit7 pin change interrupt 1: Off
; 0000 0264 PORTH.INT1MASK=0x00;
;PCODE: $000000FC VOL: 0
;PCODE: $000000FD VOL: 1
; 0000 0265 
; 0000 0266 // PORTJ initialization
; 0000 0267 // OUT register
; 0000 0268 PORTJ.OUT=0x00;
;PCODE: $000000FE VOL: 0
;PCODE: $000000FF VOL: 1
; 0000 0269 // Bit0: Input
; 0000 026A // Bit1: Input
; 0000 026B // Bit2: Input
; 0000 026C // Bit3: Input
; 0000 026D // Bit4: Input
; 0000 026E // Bit5: Input
; 0000 026F // Bit6: Input
; 0000 0270 // Bit7: Input
; 0000 0271 PORTJ.DIR=0x00;
;PCODE: $00000100 VOL: 0
;PCODE: $00000101 VOL: 1
; 0000 0272 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0273 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0274 // Bit0 inverted: Off
; 0000 0275 // Bit0 slew rate limitation: Off
; 0000 0276 PORTJ.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000102 VOL: 0
;PCODE: $00000103 VOL: 1
; 0000 0277 // Bit1 Output/Pull configuration: Totempole/No
; 0000 0278 // Bit1 Input/Sense configuration: Sense both edges
; 0000 0279 // Bit1 inverted: Off
; 0000 027A // Bit1 slew rate limitation: Off
; 0000 027B PORTJ.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000104 VOL: 0
;PCODE: $00000105 VOL: 1
; 0000 027C // Bit2 Output/Pull configuration: Totempole/No
; 0000 027D // Bit2 Input/Sense configuration: Sense both edges
; 0000 027E // Bit2 inverted: Off
; 0000 027F // Bit2 slew rate limitation: Off
; 0000 0280 PORTJ.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000106 VOL: 0
;PCODE: $00000107 VOL: 1
; 0000 0281 // Bit3 Output/Pull configuration: Totempole/No
; 0000 0282 // Bit3 Input/Sense configuration: Sense both edges
; 0000 0283 // Bit3 inverted: Off
; 0000 0284 // Bit3 slew rate limitation: Off
; 0000 0285 PORTJ.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000108 VOL: 0
;PCODE: $00000109 VOL: 1
; 0000 0286 // Bit4 Output/Pull configuration: Totempole/No
; 0000 0287 // Bit4 Input/Sense configuration: Sense both edges
; 0000 0288 // Bit4 inverted: Off
; 0000 0289 // Bit4 slew rate limitation: Off
; 0000 028A PORTJ.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000010A VOL: 0
;PCODE: $0000010B VOL: 1
; 0000 028B // Bit5 Output/Pull configuration: Totempole/No
; 0000 028C // Bit5 Input/Sense configuration: Sense both edges
; 0000 028D // Bit5 inverted: Off
; 0000 028E // Bit5 slew rate limitation: Off
; 0000 028F PORTJ.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000010C VOL: 0
;PCODE: $0000010D VOL: 1
; 0000 0290 // Bit6 Output/Pull configuration: Totempole/No
; 0000 0291 // Bit6 Input/Sense configuration: Sense both edges
; 0000 0292 // Bit6 inverted: Off
; 0000 0293 // Bit6 slew rate limitation: Off
; 0000 0294 PORTJ.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000010E VOL: 0
;PCODE: $0000010F VOL: 1
; 0000 0295 // Bit7 Output/Pull configuration: Totempole/No
; 0000 0296 // Bit7 Input/Sense configuration: Sense both edges
; 0000 0297 // Bit7 inverted: Off
; 0000 0298 // Bit7 slew rate limitation: Off
; 0000 0299 PORTJ.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000110 VOL: 0
;PCODE: $00000111 VOL: 1
; 0000 029A // Interrupt 0 level: Disabled
; 0000 029B // Interrupt 1 level: Disabled
; 0000 029C PORTJ.INTCTRL=(PORTJ.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 029D 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000112 VOL: 1
;PCODE: $00000113 VOL: 0
;PCODE: $00000114 VOL: 0
;PCODE: $00000115 VOL: 0
;PCODE: $00000116 VOL: 1
; 0000 029E // Bit0 pin change interrupt 0: Off
; 0000 029F // Bit1 pin change interrupt 0: Off
; 0000 02A0 // Bit2 pin change interrupt 0: Off
; 0000 02A1 // Bit3 pin change interrupt 0: Off
; 0000 02A2 // Bit4 pin change interrupt 0: Off
; 0000 02A3 // Bit5 pin change interrupt 0: Off
; 0000 02A4 // Bit6 pin change interrupt 0: Off
; 0000 02A5 // Bit7 pin change interrupt 0: Off
; 0000 02A6 PORTJ.INT0MASK=0x00;
;PCODE: $00000117 VOL: 0
;PCODE: $00000118 VOL: 1
; 0000 02A7 // Bit0 pin change interrupt 1: Off
; 0000 02A8 // Bit1 pin change interrupt 1: Off
; 0000 02A9 // Bit2 pin change interrupt 1: Off
; 0000 02AA // Bit3 pin change interrupt 1: Off
; 0000 02AB // Bit4 pin change interrupt 1: Off
; 0000 02AC // Bit5 pin change interrupt 1: Off
; 0000 02AD // Bit6 pin change interrupt 1: Off
; 0000 02AE // Bit7 pin change interrupt 1: Off
; 0000 02AF PORTJ.INT1MASK=0x00;
;PCODE: $00000119 VOL: 0
;PCODE: $0000011A VOL: 1
; 0000 02B0 
; 0000 02B1 // PORTK initialization
; 0000 02B2 // OUT register
; 0000 02B3 PORTK.OUT=0x00;
;PCODE: $0000011B VOL: 0
;PCODE: $0000011C VOL: 1
; 0000 02B4 // Bit0: Input
; 0000 02B5 // Bit1: Input
; 0000 02B6 // Bit2: Input
; 0000 02B7 // Bit3: Input
; 0000 02B8 // Bit4: Input
; 0000 02B9 // Bit5: Input
; 0000 02BA // Bit6: Input
; 0000 02BB // Bit7: Input
; 0000 02BC PORTK.DIR=0x00;
;PCODE: $0000011D VOL: 0
;PCODE: $0000011E VOL: 1
; 0000 02BD // Bit0 Output/Pull configuration: Totempole/No
; 0000 02BE // Bit0 Input/Sense configuration: Sense both edges
; 0000 02BF // Bit0 inverted: Off
; 0000 02C0 // Bit0 slew rate limitation: Off
; 0000 02C1 PORTK.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000011F VOL: 0
;PCODE: $00000120 VOL: 1
; 0000 02C2 // Bit1 Output/Pull configuration: Totempole/No
; 0000 02C3 // Bit1 Input/Sense configuration: Sense both edges
; 0000 02C4 // Bit1 inverted: Off
; 0000 02C5 // Bit1 slew rate limitation: Off
; 0000 02C6 PORTK.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000121 VOL: 0
;PCODE: $00000122 VOL: 1
; 0000 02C7 // Bit2 Output/Pull configuration: Totempole/No
; 0000 02C8 // Bit2 Input/Sense configuration: Sense both edges
; 0000 02C9 // Bit2 inverted: Off
; 0000 02CA // Bit2 slew rate limitation: Off
; 0000 02CB PORTK.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000123 VOL: 0
;PCODE: $00000124 VOL: 1
; 0000 02CC // Bit3 Output/Pull configuration: Totempole/No
; 0000 02CD // Bit3 Input/Sense configuration: Sense both edges
; 0000 02CE // Bit3 inverted: Off
; 0000 02CF // Bit3 slew rate limitation: Off
; 0000 02D0 PORTK.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000125 VOL: 0
;PCODE: $00000126 VOL: 1
; 0000 02D1 // Bit4 Output/Pull configuration: Totempole/No
; 0000 02D2 // Bit4 Input/Sense configuration: Sense both edges
; 0000 02D3 // Bit4 inverted: Off
; 0000 02D4 // Bit4 slew rate limitation: Off
; 0000 02D5 PORTK.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000127 VOL: 0
;PCODE: $00000128 VOL: 1
; 0000 02D6 // Bit5 Output/Pull configuration: Totempole/No
; 0000 02D7 // Bit5 Input/Sense configuration: Sense both edges
; 0000 02D8 // Bit5 inverted: Off
; 0000 02D9 // Bit5 slew rate limitation: Off
; 0000 02DA PORTK.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000129 VOL: 0
;PCODE: $0000012A VOL: 1
; 0000 02DB // Bit6 Output/Pull configuration: Totempole/No
; 0000 02DC // Bit6 Input/Sense configuration: Sense both edges
; 0000 02DD // Bit6 inverted: Off
; 0000 02DE // Bit6 slew rate limitation: Off
; 0000 02DF PORTK.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000012B VOL: 0
;PCODE: $0000012C VOL: 1
; 0000 02E0 // Bit7 Output/Pull configuration: Totempole/No
; 0000 02E1 // Bit7 Input/Sense configuration: Sense both edges
; 0000 02E2 // Bit7 inverted: Off
; 0000 02E3 // Bit7 slew rate limitation: Off
; 0000 02E4 PORTK.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000012D VOL: 0
;PCODE: $0000012E VOL: 1
; 0000 02E5 // Interrupt 0 level: Disabled
; 0000 02E6 // Interrupt 1 level: Disabled
; 0000 02E7 PORTK.INTCTRL=(PORTK.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 02E8 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $0000012F VOL: 1
;PCODE: $00000130 VOL: 0
;PCODE: $00000131 VOL: 0
;PCODE: $00000132 VOL: 0
;PCODE: $00000133 VOL: 1
; 0000 02E9 // Bit0 pin change interrupt 0: Off
; 0000 02EA // Bit1 pin change interrupt 0: Off
; 0000 02EB // Bit2 pin change interrupt 0: Off
; 0000 02EC // Bit3 pin change interrupt 0: Off
; 0000 02ED // Bit4 pin change interrupt 0: Off
; 0000 02EE // Bit5 pin change interrupt 0: Off
; 0000 02EF // Bit6 pin change interrupt 0: Off
; 0000 02F0 // Bit7 pin change interrupt 0: Off
; 0000 02F1 PORTK.INT0MASK=0x00;
;PCODE: $00000134 VOL: 0
;PCODE: $00000135 VOL: 1
; 0000 02F2 // Bit0 pin change interrupt 1: Off
; 0000 02F3 // Bit1 pin change interrupt 1: Off
; 0000 02F4 // Bit2 pin change interrupt 1: Off
; 0000 02F5 // Bit3 pin change interrupt 1: Off
; 0000 02F6 // Bit4 pin change interrupt 1: Off
; 0000 02F7 // Bit5 pin change interrupt 1: Off
; 0000 02F8 // Bit6 pin change interrupt 1: Off
; 0000 02F9 // Bit7 pin change interrupt 1: Off
; 0000 02FA PORTK.INT1MASK=0x00;
;PCODE: $00000136 VOL: 0
;PCODE: $00000137 VOL: 1
; 0000 02FB 
; 0000 02FC // PORTQ initialization
; 0000 02FD // OUT register
; 0000 02FE PORTQ.OUT=0x00;
;PCODE: $00000138 VOL: 0
;PCODE: $00000139 VOL: 1
; 0000 02FF // Bit0: Input
; 0000 0300 // Bit1: Input
; 0000 0301 // Bit2: Input
; 0000 0302 // Bit3: Input
; 0000 0303 PORTQ.DIR=0x00;
;PCODE: $0000013A VOL: 0
;PCODE: $0000013B VOL: 1
; 0000 0304 // Bit0 Output/Pull configuration: Totempole/No
; 0000 0305 // Bit0 Input/Sense configuration: Sense both edges
; 0000 0306 // Bit0 inverted: Off
; 0000 0307 // Bit0 slew rate limitation: Off
; 0000 0308 PORTQ.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000013C VOL: 0
;PCODE: $0000013D VOL: 1
; 0000 0309 // Bit1 Output/Pull configuration: Totempole/No
; 0000 030A // Bit1 Input/Sense configuration: Sense both edges
; 0000 030B // Bit1 inverted: Off
; 0000 030C // Bit1 slew rate limitation: Off
; 0000 030D PORTQ.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $0000013E VOL: 0
;PCODE: $0000013F VOL: 1
; 0000 030E // Bit2 Output/Pull configuration: Totempole/No
; 0000 030F // Bit2 Input/Sense configuration: Sense both edges
; 0000 0310 // Bit2 inverted: Off
; 0000 0311 // Bit2 slew rate limitation: Off
; 0000 0312 PORTQ.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000140 VOL: 0
;PCODE: $00000141 VOL: 1
; 0000 0313 // Bit3 Output/Pull configuration: Totempole/No
; 0000 0314 // Bit3 Input/Sense configuration: Sense both edges
; 0000 0315 // Bit3 inverted: Off
; 0000 0316 // Bit3 slew rate limitation: Off
; 0000 0317 PORTQ.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000142 VOL: 0
;PCODE: $00000143 VOL: 1
; 0000 0318 // Interrupt 0 level: Disabled
; 0000 0319 // Interrupt 1 level: Disabled
; 0000 031A PORTQ.INTCTRL=(PORTQ.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 031B 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000144 VOL: 1
;PCODE: $00000145 VOL: 0
;PCODE: $00000146 VOL: 0
;PCODE: $00000147 VOL: 0
;PCODE: $00000148 VOL: 1
; 0000 031C // Bit0 pin change interrupt 0: Off
; 0000 031D // Bit1 pin change interrupt 0: Off
; 0000 031E // Bit2 pin change interrupt 0: Off
; 0000 031F // Bit3 pin change interrupt 0: Off
; 0000 0320 PORTQ.INT0MASK=0x00;
;PCODE: $00000149 VOL: 0
;PCODE: $0000014A VOL: 1
; 0000 0321 // Bit0 pin change interrupt 1: Off
; 0000 0322 // Bit1 pin change interrupt 1: Off
; 0000 0323 // Bit2 pin change interrupt 1: Off
; 0000 0324 // Bit3 pin change interrupt 1: Off
; 0000 0325 PORTQ.INT1MASK=0x00;
;PCODE: $0000014B VOL: 0
;PCODE: $0000014C VOL: 1
; 0000 0326 
; 0000 0327 // PORTR initialization
; 0000 0328 // OUT register
; 0000 0329 PORTR.OUT=0x00;
;PCODE: $0000014D VOL: 0
;PCODE: $0000014E VOL: 1
; 0000 032A // Bit0: Input
; 0000 032B // Bit1: Input
; 0000 032C PORTR.DIR=0x00;
;PCODE: $0000014F VOL: 0
;PCODE: $00000150 VOL: 1
; 0000 032D // Bit0 Output/Pull configuration: Totempole/No
; 0000 032E // Bit0 Input/Sense configuration: Sense both edges
; 0000 032F // Bit0 inverted: Off
; 0000 0330 // Bit0 slew rate limitation: Off
; 0000 0331 PORTR.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000151 VOL: 0
;PCODE: $00000152 VOL: 1
; 0000 0332 // Bit1 Output/Pull configuration: Totempole/No
; 0000 0333 // Bit1 Input/Sense configuration: Sense both edges
; 0000 0334 // Bit1 inverted: Off
; 0000 0335 // Bit1 slew rate limitation: Off
; 0000 0336 PORTR.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
;PCODE: $00000153 VOL: 0
;PCODE: $00000154 VOL: 1
; 0000 0337 // Interrupt 0 level: Disabled
; 0000 0338 // Interrupt 1 level: Disabled
; 0000 0339 PORTR.INTCTRL=(PORTR.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
; 0000 033A 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
;PCODE: $00000155 VOL: 1
;PCODE: $00000156 VOL: 0
;PCODE: $00000157 VOL: 0
;PCODE: $00000158 VOL: 0
;PCODE: $00000159 VOL: 1
; 0000 033B // Bit0 pin change interrupt 0: Off
; 0000 033C // Bit1 pin change interrupt 0: Off
; 0000 033D PORTR.INT0MASK=0x00;
;PCODE: $0000015A VOL: 0
;PCODE: $0000015B VOL: 1
; 0000 033E // Bit0 pin change interrupt 1: Off
; 0000 033F // Bit1 pin change interrupt 1: Off
; 0000 0340 PORTR.INT1MASK=0x00;
;PCODE: $0000015C VOL: 0
;PCODE: $0000015D VOL: 1
; 0000 0341 }
;PCODE: $0000015E VOL: 0
;PCODE: $0000015F VOL: 0
;
;// Virtual Ports initialization
;void vports_init(void)
; 0000 0345 {
;PCODE: $00000160 VOL: 0
;PCODE: $00000161 VOL: 0
; 0000 0346 // PORTA mapped to VPORT0
; 0000 0347 // PORTB mapped to VPORT1
; 0000 0348 PORTCFG.VPCTRLA=PORTCFG_VP1MAP_PORTB_gc | PORTCFG_VP0MAP_PORTA_gc;
;PCODE: $00000162 VOL: 0
;PCODE: $00000163 VOL: 1
; 0000 0349 // PORTC mapped to VPORT2
; 0000 034A // PORTF mapped to VPORT3
; 0000 034B PORTCFG.VPCTRLB=PORTCFG_VP3MAP_PORTF_gc | PORTCFG_VP2MAP_PORTC_gc;
;PCODE: $00000164 VOL: 0
;PCODE: $00000165 VOL: 1
; 0000 034C }
;PCODE: $00000166 VOL: 0
;PCODE: $00000167 VOL: 0
;
;// Disable a Timer/Counter type 0
;void tc0_disable(TC0_t *ptc)
; 0000 0350 {
;PCODE: $00000168 VOL: 0
;PCODE: $00000169 VOL: 0
; 0000 0351 // Timer/Counter off
; 0000 0352 ptc->CTRLA=(ptc->CTRLA & (~TC0_CLKSEL_gm)) | TC_CLKSEL_OFF_gc;
;PCODE: $0000016A VOL: 0
;	*ptc -> Y+0
;PCODE: $0000016B VOL: 0
;PCODE: $0000016C VOL: 0
;PCODE: $0000016D VOL: 0
;PCODE: $0000016E VOL: 0
;PCODE: $0000016F VOL: 0
;PCODE: $00000170 VOL: 0
; 0000 0353 // Issue a reset command
; 0000 0354 ptc->CTRLFSET=TC_CMD_RESET_gc;
;PCODE: $00000171 VOL: 0
;PCODE: $00000172 VOL: 0
;PCODE: $00000173 VOL: 0
;PCODE: $00000174 VOL: 0
; 0000 0355 }
;PCODE: $00000175 VOL: 0
;PCODE: $00000176 VOL: 0
;PCODE: $00000177 VOL: 0
;
;// Timer/Counter TCC0 initialization
;void tcc0_init(void)
; 0000 0359 {
;PCODE: $00000178 VOL: 0
;PCODE: $00000179 VOL: 0
; 0000 035A unsigned char s;
; 0000 035B unsigned char n;
; 0000 035C 
; 0000 035D // Note: the correct PORTC direction for the Compare Channels outputs
; 0000 035E // is configured in the ports_init function
; 0000 035F 
; 0000 0360 // Save interrupts enabled/disabled state
; 0000 0361 s=SREG;
;PCODE: $0000017A VOL: 0
;PCODE: $0000017B VOL: 0
;	s -> R17
;	n -> R16
;PCODE: $0000017C VOL: 0
;PCODE: $0000017D VOL: 0
; 0000 0362 // Disable interrupts
; 0000 0363 #asm("cli")
;PCODE: $0000017E VOL: 0
	cli
;PCODE: $0000017F VOL: 0
; 0000 0364 
; 0000 0365 // Disable and reset the timer/counter just to be sure
; 0000 0366 tc0_disable(&TCC0);
;PCODE: $00000180 VOL: 1
;PCODE: $00000181 VOL: 0
; 0000 0367 // Clock source: Peripheral Clock/1
; 0000 0368 TCC0.CTRLA=(TCC0.CTRLA & (~TC0_CLKSEL_gm)) | TC_CLKSEL_DIV1_gc;
;PCODE: $00000182 VOL: 1
;PCODE: $00000183 VOL: 0
;PCODE: $00000184 VOL: 0
;PCODE: $00000185 VOL: 1
; 0000 0369 // Mode: Normal Operation, Overflow Int./Event on TOP
; 0000 036A // Compare/Capture on channel A: Off
; 0000 036B // Compare/Capture on channel B: Off
; 0000 036C // Compare/Capture on channel C: Off
; 0000 036D // Compare/Capture on channel D: Off
; 0000 036E TCC0.CTRLB=(TCC0.CTRLB & (~(TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm | TC0_WGMODE_gm))) |
; 0000 036F 	TC_WGMODE_NORMAL_gc;
;PCODE: $00000186 VOL: 1
;PCODE: $00000187 VOL: 0
;PCODE: $00000188 VOL: 0
;PCODE: $00000189 VOL: 1
; 0000 0370 
; 0000 0371 // Capture event source: None
; 0000 0372 // Capture event action: None
; 0000 0373 TCC0.CTRLD=(TCC0.CTRLD & (~(TC0_EVACT_gm | TC0_EVSEL_gm))) |
; 0000 0374 	TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
;PCODE: $0000018A VOL: 1
;PCODE: $0000018B VOL: 0
;PCODE: $0000018C VOL: 0
;PCODE: $0000018D VOL: 0
;PCODE: $0000018E VOL: 1
; 0000 0375 
; 0000 0376 // Overflow interrupt: Low Level
; 0000 0377 // Error interrupt: Disabled
; 0000 0378 TCC0.INTCTRLA=(TCC0.INTCTRLA & (~(TC0_ERRINTLVL_gm | TC0_OVFINTLVL_gm))) |
; 0000 0379 	TC_ERRINTLVL_OFF_gc | TC_OVFINTLVL_LO_gc;
;PCODE: $0000018F VOL: 1
;PCODE: $00000190 VOL: 0
;PCODE: $00000191 VOL: 0
;PCODE: $00000192 VOL: 0
;PCODE: $00000193 VOL: 1
; 0000 037A 
; 0000 037B // Compare/Capture channel A interrupt: Disabled
; 0000 037C // Compare/Capture channel B interrupt: Disabled
; 0000 037D // Compare/Capture channel C interrupt: Disabled
; 0000 037E // Compare/Capture channel D interrupt: Disabled
; 0000 037F TCC0.INTCTRLB=(TCC0.INTCTRLB & (~(TC0_CCDINTLVL_gm | TC0_CCCINTLVL_gm | TC0_CCBINTLVL_gm | TC0_CCAINTLVL_gm))) |
; 0000 0380 	TC_CCDINTLVL_OFF_gc | TC_CCCINTLVL_OFF_gc | TC_CCBINTLVL_OFF_gc | TC_CCAINTLVL_OFF_gc;
;PCODE: $00000194 VOL: 1
;PCODE: $00000195 VOL: 0
;PCODE: $00000196 VOL: 0
;PCODE: $00000197 VOL: 0
;PCODE: $00000198 VOL: 0
;PCODE: $00000199 VOL: 0
;PCODE: $0000019A VOL: 1
; 0000 0381 
; 0000 0382 // High resolution extension: Off
; 0000 0383 HIRESC.CTRL&= ~HIRES_HREN0_bm;
;PCODE: $0000019B VOL: 1
;PCODE: $0000019C VOL: 0
;PCODE: $0000019D VOL: 1
; 0000 0384 
; 0000 0385 // Advanced Waveform Extension initialization
; 0000 0386 // Optimize for speed
; 0000 0387 #pragma optsize-
; 0000 0388 // Disable locking the AWEX configuration registers just to be sure
; 0000 0389 n=MCU.AWEXLOCK & (~MCU_AWEXCLOCK_bm);
;PCODE: $0000019E VOL: 1
;PCODE: $0000019F VOL: 0
;PCODE: $000001A0 VOL: 0
; 0000 038A CCP=CCP_IOREG_gc;
;PCODE: $000001A1 VOL: 0
;PCODE: $000001A2 VOL: 0
; 0000 038B MCU.AWEXLOCK=n;
;PCODE: $000001A3 VOL: 1
;PCODE: $000001A4 VOL: 0
; 0000 038C // Restore optimization for size if needed
; 0000 038D #pragma optsize_default
; 0000 038E 
; 0000 038F // Pattern generation: Off
; 0000 0390 // Dead time insertion: Off
; 0000 0391 AWEXC.CTRL&= ~(AWEX_PGM_bm | AWEX_CWCM_bm | AWEX_DTICCDEN_bm | AWEX_DTICCCEN_bm | AWEX_DTICCBEN_bm | AWEX_DTICCAEN_bm);
;PCODE: $000001A5 VOL: 1
;PCODE: $000001A6 VOL: 0
;PCODE: $000001A7 VOL: 1
; 0000 0392 
; 0000 0393 // Fault protection initialization
; 0000 0394 // Fault detection on OCD Break detection: On
; 0000 0395 // Fault detection restart mode: Latched Mode
; 0000 0396 // Fault detection action: None (Fault protection disabled)
; 0000 0397 AWEXC.FDCTRL=(AWEXC.FDCTRL & (~(AWEX_FDDBD_bm | AWEX_FDMODE_bm | AWEX_FDACT_gm))) |
; 0000 0398 	AWEX_FDACT_NONE_gc;
;PCODE: $000001A8 VOL: 1
;PCODE: $000001A9 VOL: 0
;PCODE: $000001AA VOL: 0
;PCODE: $000001AB VOL: 1
; 0000 0399 // Fault detect events:
; 0000 039A // Event channel 0: Off
; 0000 039B // Event channel 1: Off
; 0000 039C // Event channel 2: Off
; 0000 039D // Event channel 3: Off
; 0000 039E // Event channel 4: Off
; 0000 039F // Event channel 5: Off
; 0000 03A0 // Event channel 6: Off
; 0000 03A1 // Event channel 7: Off
; 0000 03A2 AWEXC.FDEVMASK=0b00000000;
;PCODE: $000001AC VOL: 0
;PCODE: $000001AD VOL: 1
; 0000 03A3 // Make sure the fault detect flag is cleared
; 0000 03A4 AWEXC.STATUS|=AWEXC.STATUS & AWEX_FDF_bm;
;PCODE: $000001AE VOL: 1
;PCODE: $000001AF VOL: 0
;PCODE: $000001B0 VOL: 0
;PCODE: $000001B1 VOL: 1
;PCODE: $000001B2 VOL: 0
;PCODE: $000001B3 VOL: 0
;PCODE: $000001B4 VOL: 0
;PCODE: $000001B5 VOL: 0
; 0000 03A5 
; 0000 03A6 // Clear the interrupt flags
; 0000 03A7 TCC0.INTFLAGS=TCC0.INTFLAGS;
;PCODE: $000001B6 VOL: 1
;PCODE: $000001B7 VOL: 1
; 0000 03A8 // Set counter register
; 0000 03A9 TCC0.CNT=0x0000;
;PCODE: $000001B8 VOL: 0
;PCODE: $000001B9 VOL: 1
; 0000 03AA // Set period register
; 0000 03AB TCC0.PER=0x4E1F;
;PCODE: $000001BA VOL: 0
;PCODE: $000001BB VOL: 1
; 0000 03AC // Set channel A Compare/Capture register
; 0000 03AD TCC0.CCA=0x0000;
;PCODE: $000001BC VOL: 0
;PCODE: $000001BD VOL: 1
; 0000 03AE // Set channel B Compare/Capture register
; 0000 03AF TCC0.CCB=0x0000;
;PCODE: $000001BE VOL: 0
;PCODE: $000001BF VOL: 1
; 0000 03B0 // Set channel C Compare/Capture register
; 0000 03B1 TCC0.CCC=0x0000;
;PCODE: $000001C0 VOL: 0
;PCODE: $000001C1 VOL: 1
; 0000 03B2 // Set channel D Compare/Capture register
; 0000 03B3 TCC0.CCD=0x0000;
;PCODE: $000001C2 VOL: 0
;PCODE: $000001C3 VOL: 1
; 0000 03B4 
; 0000 03B5 // Restore interrupts enabled/disabled state
; 0000 03B6 SREG=s;
;PCODE: $000001C4 VOL: 0
;PCODE: $000001C5 VOL: 0
; 0000 03B7 }
;PCODE: $000001C6 VOL: 0
;PCODE: $000001C7 VOL: 0
;PCODE: $000001C8 VOL: 0
;
;unsigned int ten_ms=0;
;// Timer/counter TCC0 Overflow/Underflow interrupt service routine
;interrupt [TCC0_OVF_vect] void tcc0_overflow_isr(void)
; 0000 03BC {
;PCODE: $000001C9 VOL: 0
;PCODE: $000001CA VOL: 0
; 0000 03BD // write your code here
; 0000 03BE     ten_ms++;
;PCODE: $000001CB VOL: 0
;PCODE: $000001CC VOL: 0
;PCODE: $000001CD VOL: 0
; 0000 03BF }
;PCODE: $000001CE VOL: 0
;PCODE: $000001CF VOL: 0
;PCODE: $000001D0 VOL: 0
;
;// RTC initialization
;void rtcxm_init(void)
; 0000 03C3 {
;PCODE: $000001D1 VOL: 0
;PCODE: $000001D2 VOL: 0
; 0000 03C4 unsigned char s;
; 0000 03C5 
; 0000 03C6 // RTC clock source: 1024 Hz from internal 32 kHz RC Oscillator
; 0000 03C7 // Internal 32 kHz RC oscillator initialization
; 0000 03C8 // Enable the internal 32 kHz RC oscillator
; 0000 03C9 OSC.CTRL|=OSC_RC32KEN_bm;
;PCODE: $000001D3 VOL: 0
;	s -> R17
;PCODE: $000001D4 VOL: 1
;PCODE: $000001D5 VOL: 0
;PCODE: $000001D6 VOL: 1
; 0000 03CA // Wait for the internal 32 kHz RC oscillator to stabilize
; 0000 03CB while ((OSC.STATUS & OSC_RC32KRDY_bm)==0);
;PCODE: $000001D7 VOL: 0
;PCODE: $000001D8 VOL: 1
;PCODE: $000001D9 VOL: 0
;PCODE: $000001DA VOL: 0
;PCODE: $000001DB VOL: 0
;PCODE: $000001DC VOL: 0
; 0000 03CC 
; 0000 03CD // Select the clock source and enable the RTC clock
; 0000 03CE CLK.RTCCTRL=(CLK.RTCCTRL & (~CLK_RTCSRC_gm)) | CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;
;PCODE: $000001DD VOL: 1
;PCODE: $000001DE VOL: 0
;PCODE: $000001DF VOL: 0
;PCODE: $000001E0 VOL: 1
; 0000 03CF // Make sure that the RTC is stopped before initializing it
; 0000 03D0 RTC.CTRL=(RTC.CTRL & (~RTC_PRESCALER_gm)) | RTC_PRESCALER_OFF_gc;
;PCODE: $000001E1 VOL: 1
;PCODE: $000001E2 VOL: 0
;PCODE: $000001E3 VOL: 0
;PCODE: $000001E4 VOL: 1
; 0000 03D1 
; 0000 03D2 // Optimize for speed
; 0000 03D3 #pragma optsize-
; 0000 03D4 // Save interrupts enabled/disabled state
; 0000 03D5 s=SREG;
;PCODE: $000001E5 VOL: 0
;PCODE: $000001E6 VOL: 0
; 0000 03D6 // Disable interrupts
; 0000 03D7 #asm("cli")
;PCODE: $000001E7 VOL: 0
	cli
;PCODE: $000001E8 VOL: 0
; 0000 03D8 
; 0000 03D9 // Wait until the RTC is not busy
; 0000 03DA while (RTC.STATUS & RTC_SYNCBUSY_bm);
;PCODE: $000001E9 VOL: 0
;PCODE: $000001EA VOL: 1
;PCODE: $000001EB VOL: 0
;PCODE: $000001EC VOL: 0
;PCODE: $000001ED VOL: 0
;PCODE: $000001EE VOL: 0
; 0000 03DB // Set the RTC period register
; 0000 03DC RTC.PER=0x0400;
;PCODE: $000001EF VOL: 0
;PCODE: $000001F0 VOL: 1
; 0000 03DD // Set the RTC count register
; 0000 03DE RTC.CNT=0x0000;
;PCODE: $000001F1 VOL: 0
;PCODE: $000001F2 VOL: 1
; 0000 03DF // Set the RTC compare register
; 0000 03E0 RTC.COMP=0x0000;
;PCODE: $000001F3 VOL: 0
;PCODE: $000001F4 VOL: 1
; 0000 03E1 
; 0000 03E2 // Restore interrupts enabled/disabled state
; 0000 03E3 SREG=s;
;PCODE: $000001F5 VOL: 0
;PCODE: $000001F6 VOL: 0
; 0000 03E4 // Restore optimization for size if needed
; 0000 03E5 #pragma optsize_default
; 0000 03E6 
; 0000 03E7 // Set the clock prescaler: RTC Clock/1
; 0000 03E8 // and start the RTC
; 0000 03E9 RTC.CTRL=(RTC.CTRL & (~RTC_PRESCALER_gm)) | RTC_PRESCALER_DIV1_gc;
;PCODE: $000001F7 VOL: 1
;PCODE: $000001F8 VOL: 0
;PCODE: $000001F9 VOL: 0
;PCODE: $000001FA VOL: 1
; 0000 03EA 
; 0000 03EB // RTC overflow interrupt: Low Level
; 0000 03EC // RTC compare interrupt: Disabled
; 0000 03ED RTC.INTCTRL=(RTC.INTCTRL & (~(RTC_OVFINTLVL_gm | RTC_COMPINTLVL_gm))) |
; 0000 03EE 	RTC_OVFINTLVL_LO_gc | RTC_COMPINTLVL_OFF_gc;
;PCODE: $000001FB VOL: 1
;PCODE: $000001FC VOL: 0
;PCODE: $000001FD VOL: 0
;PCODE: $000001FE VOL: 0
;PCODE: $000001FF VOL: 1
; 0000 03EF }
;PCODE: $00000200 VOL: 0
;PCODE: $00000201 VOL: 0
;PCODE: $00000202 VOL: 0
;
;unsigned int sec=0;
;// RTC overflow interrupt service routine
;interrupt [RTC_OVF_vect] void rtcxm_overflow_isr(void)
; 0000 03F4 {
;PCODE: $00000203 VOL: 0
;PCODE: $00000204 VOL: 0
; 0000 03F5 // write your code here
; 0000 03F6     sec++;
;PCODE: $00000205 VOL: 0
;PCODE: $00000206 VOL: 0
;PCODE: $00000207 VOL: 0
; 0000 03F7 }
;PCODE: $00000208 VOL: 0
;PCODE: $00000209 VOL: 0
;PCODE: $0000020A VOL: 0
;
;// USARTC0 initialization
;void usartc0_init(void)
; 0000 03FB {
;PCODE: $0000020B VOL: 0
;PCODE: $0000020C VOL: 0
; 0000 03FC // Note: the correct PORTC direction for the RxD, TxD and XCK signals
; 0000 03FD // is configured in the ports_init function
; 0000 03FE 
; 0000 03FF // Transmitter is enabled
; 0000 0400 // Set TxD=1
; 0000 0401 PORTC.OUTSET=0x08;
;PCODE: $0000020D VOL: 0
;PCODE: $0000020E VOL: 1
; 0000 0402 
; 0000 0403 // Communication mode: Asynchronous USART
; 0000 0404 // Data bits: 8
; 0000 0405 // Stop bits: 1
; 0000 0406 // Parity: Disabled
; 0000 0407 USARTC0.CTRLC=USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc;
;PCODE: $0000020F VOL: 0
;PCODE: $00000210 VOL: 1
; 0000 0408 
; 0000 0409 // Receive complete interrupt: Low Level
; 0000 040A // Transmit complete interrupt: Disabled
; 0000 040B // Data register empty interrupt: Disabled
; 0000 040C USARTC0.CTRLA=(USARTC0.CTRLA & (~(USART_RXCINTLVL_gm | USART_TXCINTLVL_gm | USART_DREINTLVL_gm))) |
; 0000 040D 	USART_RXCINTLVL_LO_gc | USART_TXCINTLVL_OFF_gc | USART_DREINTLVL_OFF_gc;
;PCODE: $00000211 VOL: 1
;PCODE: $00000212 VOL: 0
;PCODE: $00000213 VOL: 0
;PCODE: $00000214 VOL: 0
;PCODE: $00000215 VOL: 0
;PCODE: $00000216 VOL: 1
; 0000 040E 
; 0000 040F // Required Baud rate: 115200
; 0000 0410 // Real Baud Rate: 115107.9 (x1 Mode), Error: 0.1 %
; 0000 0411 USARTC0.BAUDCTRLA=0x0B;
;PCODE: $00000217 VOL: 0
;PCODE: $00000218 VOL: 1
; 0000 0412 USARTC0.BAUDCTRLB=((0x09 << USART_BSCALE_bp) & USART_BSCALE_gm) | 0x00;
;PCODE: $00000219 VOL: 0
;PCODE: $0000021A VOL: 1
; 0000 0413 
; 0000 0414 // Receiver: On
; 0000 0415 // Transmitter: On
; 0000 0416 // Double transmission speed mode: Off
; 0000 0417 // Multi-processor communication mode: Off
; 0000 0418 USARTC0.CTRLB=(USARTC0.CTRLB & (~(USART_RXEN_bm | USART_TXEN_bm | USART_CLK2X_bm | USART_MPCM_bm | USART_TXB8_bm))) |
; 0000 0419 	USART_RXEN_bm | USART_TXEN_bm;
;PCODE: $0000021B VOL: 1
;PCODE: $0000021C VOL: 0
;PCODE: $0000021D VOL: 0
;PCODE: $0000021E VOL: 1
; 0000 041A }
;PCODE: $0000021F VOL: 0
;PCODE: $00000220 VOL: 0
;
;// USARTC0 Receiver buffer
;#define RX_BUFFER_SIZE_USARTC0 8
;char rx_buffer_usartc0[RX_BUFFER_SIZE_USARTC0];
;
;#if RX_BUFFER_SIZE_USARTC0 <= 256
;unsigned char rx_wr_index_usartc0=0,rx_rd_index_usartc0=0,rx_counter_usartc0=0;
;#else
;unsigned int rx_wr_index_usartc0=0,rx_rd_index_usartc0=0,rx_counter_usartc0=0;
;#endif
;
;// This flag is set on USARTC0 Receiver buffer overflow
;bit rx_buffer_overflow_usartc0=0;
;
;// USARTC0 Receiver interrupt service routine
;interrupt [USARTC0_RXC_vect] void usartc0_rx_isr(void)
; 0000 042B {
;PCODE: $00000221 VOL: 0
;PCODE: $00000222 VOL: 0
; 0000 042C unsigned char status;
; 0000 042D char data;
; 0000 042E 
; 0000 042F status=USARTC0.STATUS;
;PCODE: $00000223 VOL: 0
;PCODE: $00000224 VOL: 0
;	status -> R17
;	data -> R16
;PCODE: $00000225 VOL: 0
;PCODE: $00000226 VOL: 1
; 0000 0430 data=USARTC0.DATA;
;PCODE: $00000227 VOL: 0
;PCODE: $00000228 VOL: 1
; 0000 0431 if ((status & (USART_FERR_bm | USART_PERR_bm | USART_BUFOVF_bm)) == 0)
;PCODE: $00000229 VOL: 0
;PCODE: $0000022A VOL: 0
;PCODE: $0000022B VOL: 0
; 0000 0432    {
; 0000 0433    rx_buffer_usartc0[rx_wr_index_usartc0++]=data;
;PCODE: $0000022C VOL: 0
;PCODE: $0000022D VOL: 0
;PCODE: $0000022E VOL: 0
;PCODE: $0000022F VOL: 0
;PCODE: $00000230 VOL: 0
; 0000 0434 #if RX_BUFFER_SIZE_USARTC0 == 256
; 0000 0435    // special case for receiver buffer size=256
; 0000 0436    if (++rx_counter_usartc0 == 0) rx_buffer_overflow_usartc0=1;
; 0000 0437 #else
; 0000 0438    if (rx_wr_index_usartc0 == RX_BUFFER_SIZE_USARTC0) rx_wr_index_usartc0=0;
;PCODE: $00000231 VOL: 0
;PCODE: $00000232 VOL: 0
;PCODE: $00000233 VOL: 0
;PCODE: $00000234 VOL: 0
; 0000 0439    if (++rx_counter_usartc0 == RX_BUFFER_SIZE_USARTC0)
;PCODE: $00000235 VOL: 0
;PCODE: $00000236 VOL: 0
;PCODE: $00000237 VOL: 0
;PCODE: $00000238 VOL: 0
;PCODE: $00000239 VOL: 0
; 0000 043A       {
; 0000 043B       rx_counter_usartc0=0;
;PCODE: $0000023A VOL: 0
; 0000 043C       rx_buffer_overflow_usartc0=1;
;PCODE: $0000023B VOL: 0
;PCODE: $0000023C VOL: 0
; 0000 043D       }
; 0000 043E #endif
; 0000 043F    }
;PCODE: $0000023D VOL: 0
; 0000 0440 }
;PCODE: $0000023E VOL: 0
;PCODE: $0000023F VOL: 0
;PCODE: $00000240 VOL: 0
;PCODE: $00000241 VOL: 0
;PCODE: $00000242 VOL: 0
;
;// Receive a character from USARTC0
;// USARTC0 is used as the default input device by the 'getchar' function
;#define _ALTERNATE_GETCHAR_
;
;#pragma used+
;char getchar(void)
; 0000 0448 {
;PCODE: $00000243 VOL: 0
;PCODE: $00000244 VOL: 0
; 0000 0449 char data;
; 0000 044A 
; 0000 044B while (rx_counter_usartc0==0);
;PCODE: $00000245 VOL: 0
;	data -> R17
;PCODE: $00000246 VOL: 0
;PCODE: $00000247 VOL: 0
;PCODE: $00000248 VOL: 0
;PCODE: $00000249 VOL: 0
;PCODE: $0000024A VOL: 0
; 0000 044C data=rx_buffer_usartc0[rx_rd_index_usartc0++];
;PCODE: $0000024B VOL: 0
;PCODE: $0000024C VOL: 0
;PCODE: $0000024D VOL: 0
;PCODE: $0000024E VOL: 0
;PCODE: $0000024F VOL: 0
; 0000 044D #if RX_BUFFER_SIZE_USARTC0 != 256
; 0000 044E if (rx_rd_index_usartc0 == RX_BUFFER_SIZE_USARTC0) rx_rd_index_usartc0=0;
;PCODE: $00000250 VOL: 0
;PCODE: $00000251 VOL: 0
;PCODE: $00000252 VOL: 0
;PCODE: $00000253 VOL: 0
; 0000 044F #endif
; 0000 0450 #asm("cli")
;PCODE: $00000254 VOL: 0
;PCODE: $00000255 VOL: 0
	cli
;PCODE: $00000256 VOL: 0
; 0000 0451 --rx_counter_usartc0;
;PCODE: $00000257 VOL: 0
; 0000 0452 #asm("sei")
;PCODE: $00000258 VOL: 0
	sei
;PCODE: $00000259 VOL: 0
; 0000 0453 return data;
;PCODE: $0000025A VOL: 0
;PCODE: $0000025B VOL: 0
;PCODE: $0000025C VOL: 0
; 0000 0454 }
;PCODE: $0000025D VOL: 0
;#pragma used-
;
;// Write a character to the USARTC0 Transmitter
;// USARTC0 is used as the default output device by the 'putchar' function
;#define _ALTERNATE_PUTCHAR_
;
;#pragma used+
;void putchar(char c)
; 0000 045D {
;PCODE: $0000025E VOL: 0
;PCODE: $0000025F VOL: 0
; 0000 045E while ((USARTC0.STATUS & USART_DREIF_bm) == 0);
;PCODE: $00000260 VOL: 0
;	c -> Y+0
;PCODE: $00000261 VOL: 0
;PCODE: $00000262 VOL: 1
;PCODE: $00000263 VOL: 0
;PCODE: $00000264 VOL: 0
;PCODE: $00000265 VOL: 0
;PCODE: $00000266 VOL: 0
; 0000 045F USARTC0.DATA=c;
;PCODE: $00000267 VOL: 0
;PCODE: $00000268 VOL: 1
; 0000 0460 }
;PCODE: $00000269 VOL: 0
;PCODE: $0000026A VOL: 0
;PCODE: $0000026B VOL: 0
;#pragma used-
;
;// USARTD0 initialization
;void usartd0_init(void)
; 0000 0465 {
;PCODE: $0000026C VOL: 0
;PCODE: $0000026D VOL: 0
; 0000 0466 // Note: the correct PORTD direction for the RxD, TxD and XCK signals
; 0000 0467 // is configured in the ports_init function
; 0000 0468 
; 0000 0469 // Transmitter is enabled
; 0000 046A // Set TxD=1
; 0000 046B PORTD.OUTSET=0x08;
;PCODE: $0000026E VOL: 0
;PCODE: $0000026F VOL: 1
; 0000 046C 
; 0000 046D // Communication mode: Asynchronous USART
; 0000 046E // Data bits: 8
; 0000 046F // Stop bits: 1
; 0000 0470 // Parity: Disabled
; 0000 0471 USARTD0.CTRLC=USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc;
;PCODE: $00000270 VOL: 0
;PCODE: $00000271 VOL: 1
; 0000 0472 
; 0000 0473 // Receive complete interrupt: Low Level
; 0000 0474 // Transmit complete interrupt: Disabled
; 0000 0475 // Data register empty interrupt: Disabled
; 0000 0476 USARTD0.CTRLA=(USARTD0.CTRLA & (~(USART_RXCINTLVL_gm | USART_TXCINTLVL_gm | USART_DREINTLVL_gm))) |
; 0000 0477 	USART_RXCINTLVL_LO_gc | USART_TXCINTLVL_OFF_gc | USART_DREINTLVL_OFF_gc;
;PCODE: $00000272 VOL: 1
;PCODE: $00000273 VOL: 0
;PCODE: $00000274 VOL: 0
;PCODE: $00000275 VOL: 0
;PCODE: $00000276 VOL: 0
;PCODE: $00000277 VOL: 1
; 0000 0478 
; 0000 0479 // Required Baud rate: 115200
; 0000 047A // Real Baud Rate: 115107.9 (x1 Mode), Error: 0.1 %
; 0000 047B USARTD0.BAUDCTRLA=0x0B;
;PCODE: $00000278 VOL: 0
;PCODE: $00000279 VOL: 1
; 0000 047C USARTD0.BAUDCTRLB=((0x09 << USART_BSCALE_bp) & USART_BSCALE_gm) | 0x00;
;PCODE: $0000027A VOL: 0
;PCODE: $0000027B VOL: 1
; 0000 047D 
; 0000 047E // Receiver: On
; 0000 047F // Transmitter: On
; 0000 0480 // Double transmission speed mode: Off
; 0000 0481 // Multi-processor communication mode: Off
; 0000 0482 USARTD0.CTRLB=(USARTD0.CTRLB & (~(USART_RXEN_bm | USART_TXEN_bm | USART_CLK2X_bm | USART_MPCM_bm | USART_TXB8_bm))) |
; 0000 0483 	USART_RXEN_bm | USART_TXEN_bm;
;PCODE: $0000027C VOL: 1
;PCODE: $0000027D VOL: 0
;PCODE: $0000027E VOL: 0
;PCODE: $0000027F VOL: 1
; 0000 0484 }
;PCODE: $00000280 VOL: 0
;PCODE: $00000281 VOL: 0
;
;// USARTD0 Receiver buffer
;#define RX_BUFFER_SIZE_USARTD0 8
;char rx_buffer_usartd0[RX_BUFFER_SIZE_USARTD0];
;
;#if RX_BUFFER_SIZE_USARTD0 <= 256
;unsigned char rx_wr_index_usartd0=0,rx_rd_index_usartd0=0,rx_counter_usartd0=0;
;#else
;unsigned int rx_wr_index_usartd0=0,rx_rd_index_usartd0=0,rx_counter_usartd0=0;
;#endif
;
;// This flag is set on USARTD0 Receiver buffer overflow
;bit rx_buffer_overflow_usartd0=0;
;
;// USARTD0 Receiver interrupt service routine
;interrupt [USARTD0_RXC_vect] void usartd0_rx_isr(void)
; 0000 0495 {
;PCODE: $00000282 VOL: 0
;PCODE: $00000283 VOL: 0
; 0000 0496 unsigned char status;
; 0000 0497 char data;
; 0000 0498 
; 0000 0499 status=USARTD0.STATUS;
;PCODE: $00000284 VOL: 0
;PCODE: $00000285 VOL: 0
;	status -> R17
;	data -> R16
;PCODE: $00000286 VOL: 0
;PCODE: $00000287 VOL: 1
; 0000 049A data=USARTD0.DATA;
;PCODE: $00000288 VOL: 0
;PCODE: $00000289 VOL: 1
; 0000 049B if ((status & (USART_FERR_bm | USART_PERR_bm | USART_BUFOVF_bm)) == 0)
;PCODE: $0000028A VOL: 0
;PCODE: $0000028B VOL: 0
;PCODE: $0000028C VOL: 0
; 0000 049C    {
; 0000 049D    rx_buffer_usartd0[rx_wr_index_usartd0++]=data;
;PCODE: $0000028D VOL: 0
;PCODE: $0000028E VOL: 0
;PCODE: $0000028F VOL: 0
;PCODE: $00000290 VOL: 0
;PCODE: $00000291 VOL: 0
; 0000 049E #if RX_BUFFER_SIZE_USARTD0 == 256
; 0000 049F    // special case for receiver buffer size=256
; 0000 04A0    if (++rx_counter_usartd0 == 0) rx_buffer_overflow_usartd0=1;
; 0000 04A1 #else
; 0000 04A2    if (rx_wr_index_usartd0 == RX_BUFFER_SIZE_USARTD0) rx_wr_index_usartd0=0;
;PCODE: $00000292 VOL: 0
;PCODE: $00000293 VOL: 0
;PCODE: $00000294 VOL: 0
;PCODE: $00000295 VOL: 0
; 0000 04A3    if (++rx_counter_usartd0 == RX_BUFFER_SIZE_USARTD0)
;PCODE: $00000296 VOL: 0
;PCODE: $00000297 VOL: 0
;PCODE: $00000298 VOL: 0
;PCODE: $00000299 VOL: 0
;PCODE: $0000029A VOL: 0
; 0000 04A4       {
; 0000 04A5       rx_counter_usartd0=0;
;PCODE: $0000029B VOL: 0
; 0000 04A6       rx_buffer_overflow_usartd0=1;
;PCODE: $0000029C VOL: 0
;PCODE: $0000029D VOL: 0
; 0000 04A7       }
; 0000 04A8 #endif
; 0000 04A9    }
;PCODE: $0000029E VOL: 0
; 0000 04AA }
;PCODE: $0000029F VOL: 0
;PCODE: $000002A0 VOL: 0
;PCODE: $000002A1 VOL: 0
;PCODE: $000002A2 VOL: 0
;PCODE: $000002A3 VOL: 0
;
;// Receive a character from USARTD0
;#pragma used+
;char getchar_usartd0(void)
; 0000 04AF {
;PCODE: $000002A4 VOL: 0
;PCODE: $000002A5 VOL: 0
; 0000 04B0 char data;
; 0000 04B1 
; 0000 04B2 while (rx_counter_usartd0==0);
;PCODE: $000002A6 VOL: 0
;	data -> R17
;PCODE: $000002A7 VOL: 0
;PCODE: $000002A8 VOL: 0
;PCODE: $000002A9 VOL: 0
;PCODE: $000002AA VOL: 0
;PCODE: $000002AB VOL: 0
; 0000 04B3 data=rx_buffer_usartd0[rx_rd_index_usartd0++];
;PCODE: $000002AC VOL: 0
;PCODE: $000002AD VOL: 0
;PCODE: $000002AE VOL: 0
;PCODE: $000002AF VOL: 0
;PCODE: $000002B0 VOL: 0
; 0000 04B4 #if RX_BUFFER_SIZE_USARTD0 != 256
; 0000 04B5 if (rx_rd_index_usartd0 == RX_BUFFER_SIZE_USARTD0) rx_rd_index_usartd0=0;
;PCODE: $000002B1 VOL: 0
;PCODE: $000002B2 VOL: 0
;PCODE: $000002B3 VOL: 0
;PCODE: $000002B4 VOL: 0
; 0000 04B6 #endif
; 0000 04B7 #asm("cli")
;PCODE: $000002B5 VOL: 0
;PCODE: $000002B6 VOL: 0
	cli
;PCODE: $000002B7 VOL: 0
; 0000 04B8 --rx_counter_usartd0;
;PCODE: $000002B8 VOL: 0
; 0000 04B9 #asm("sei")
;PCODE: $000002B9 VOL: 0
	sei
;PCODE: $000002BA VOL: 0
; 0000 04BA return data;
;PCODE: $000002BB VOL: 0
;PCODE: $000002BC VOL: 0
;PCODE: $000002BD VOL: 0
; 0000 04BB }
;PCODE: $000002BE VOL: 0
;#pragma used-
;
;// Write a character to the USARTD0 Transmitter
;#pragma used+
;void putchar_usartd0(char c)
; 0000 04C1 {
;PCODE: $000002BF VOL: 0
;PCODE: $000002C0 VOL: 0
; 0000 04C2 while ((USARTD0.STATUS & USART_DREIF_bm) == 0);
;PCODE: $000002C1 VOL: 0
;	c -> Y+0
;PCODE: $000002C2 VOL: 0
;PCODE: $000002C3 VOL: 1
;PCODE: $000002C4 VOL: 0
;PCODE: $000002C5 VOL: 0
;PCODE: $000002C6 VOL: 0
;PCODE: $000002C7 VOL: 0
; 0000 04C3 USARTD0.DATA=c;
;PCODE: $000002C8 VOL: 0
;PCODE: $000002C9 VOL: 1
; 0000 04C4 }
;PCODE: $000002CA VOL: 0
;PCODE: $000002CB VOL: 0
;PCODE: $000002CC VOL: 0
;#pragma used-
;
;// Function used to read the calibration byte from the
;// signature row, specified by 'index'
;#pragma optsize-
;unsigned char read_calibration_byte(unsigned char index)
; 0000 04CB {
;PCODE: $000002CD VOL: 0
;PCODE: $000002CE VOL: 0
; 0000 04CC unsigned char r;
; 0000 04CD NVM.CMD=NVM_CMD_READ_CALIB_ROW_gc;
;PCODE: $000002CF VOL: 0
;PCODE: $000002D0 VOL: 0
;	index -> Y+1
;	r -> R17
;PCODE: $000002D1 VOL: 0
;PCODE: $000002D2 VOL: 1
; 0000 04CE r=*((flash unsigned char*) index);
;PCODE: $000002D3 VOL: 0
;PCODE: $000002D4 VOL: 0
;PCODE: $000002D5 VOL: 0
; 0000 04CF // Clean up NVM command register
; 0000 04D0 NVM.CMD=NVM_CMD_NO_OPERATION_gc;
;PCODE: $000002D6 VOL: 0
;PCODE: $000002D7 VOL: 1
; 0000 04D1 return r;
;PCODE: $000002D8 VOL: 0
;PCODE: $000002D9 VOL: 0
;PCODE: $000002DA VOL: 0
;PCODE: $000002DB VOL: 0
;PCODE: $000002DC VOL: 0
; 0000 04D2 }
;PCODE: $000002DD VOL: 0
;#pragma optsize_default
;
;// ADCA initialization
;
;// Variable used to store the ADC offset
;// for 12 Bit Unsigned conversion mode
;unsigned char adca_offset;
;
;void adca_init(void)
; 0000 04DC {
;PCODE: $000002DE VOL: 0
;PCODE: $000002DF VOL: 0
; 0000 04DD unsigned char i;
; 0000 04DE unsigned int offs;
; 0000 04DF 
; 0000 04E0 // ADCA is enabled
; 0000 04E1 // Resolution: 12 Bits
; 0000 04E2 // Load the calibration value for 12 Bit resolution
; 0000 04E3 // from the signature row
; 0000 04E4 ADCA.CALL=read_calibration_byte(PROD_SIGNATURES_START+ADCACAL0_offset);
;PCODE: $000002E0 VOL: 0
;	i -> R17
;	offs -> R18,R19
;PCODE: $000002E1 VOL: 0
;PCODE: $000002E2 VOL: 0
;PCODE: $000002E3 VOL: 1
; 0000 04E5 ADCA.CALH=read_calibration_byte(PROD_SIGNATURES_START+ADCACAL1_offset);
;PCODE: $000002E4 VOL: 0
;PCODE: $000002E5 VOL: 0
;PCODE: $000002E6 VOL: 1
; 0000 04E6 
; 0000 04E7 // Free Running mode: Off
; 0000 04E8 // Conversion mode: Unsigned
; 0000 04E9 ADCA.CTRLB=(ADCA.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) |
; 0000 04EA 	ADC_RESOLUTION_12BIT_gc;
;PCODE: $000002E7 VOL: 1
;PCODE: $000002E8 VOL: 0
;PCODE: $000002E9 VOL: 0
;PCODE: $000002EA VOL: 1
; 0000 04EB 
; 0000 04EC // Clock frequency: 3.906 kHz
; 0000 04ED ADCA.PRESCALER=(ADCA.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV512_gc;
;PCODE: $000002EB VOL: 1
;PCODE: $000002EC VOL: 0
;PCODE: $000002ED VOL: 1
; 0000 04EE 
; 0000 04EF // Reference: AREF pin on PORTB
; 0000 04F0 // Temperature reference: On
; 0000 04F1 ADCA.REFCTRL=(ADCA.REFCTRL & ((~(ADC_REFSEL_gm | ADC_TEMPREF_bm)) | ADC_BANDGAP_bm)) |
; 0000 04F2 	ADC_REFSEL_AREFB_gc | ADC_TEMPREF_bm;
;PCODE: $000002EE VOL: 1
;PCODE: $000002EF VOL: 0
;PCODE: $000002F0 VOL: 1
; 0000 04F3 
; 0000 04F4 // Read and save the ADC offset using channel 0
; 0000 04F5 // ADC4 pin connected to GND
; 0000 04F6 ADCA.CH0.CTRL=(ADCA.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAINFAC_gm | ADC_CH_INPUTMODE_gm))) |
; 0000 04F7 	ADC_CH_INPUTMODE_SINGLEENDED_gc;
;PCODE: $000002F1 VOL: 1
;PCODE: $000002F2 VOL: 0
;PCODE: $000002F3 VOL: 0
;PCODE: $000002F4 VOL: 1
; 0000 04F8 ADCA.CH0.MUXCTRL=(ADCA.CH0.MUXCTRL & (~(ADC_CH_MUXPOS_gm | ADC_CH_MUXNEG_gm))) |
; 0000 04F9 	ADC_CH_MUXPOS_PIN4_gc;
;PCODE: $000002F5 VOL: 1
;PCODE: $000002F6 VOL: 0
;PCODE: $000002F7 VOL: 0
;PCODE: $000002F8 VOL: 1
; 0000 04FA // Enable the ADC in order to read the offset
; 0000 04FB ADCA.CTRLA|=ADC_ENABLE_bm;
;PCODE: $000002F9 VOL: 1
;PCODE: $000002FA VOL: 0
;PCODE: $000002FB VOL: 1
; 0000 04FC // Insert a delay to allow the ADC common mode voltage to stabilize
; 0000 04FD delay_us(2);
;PCODE: $000002FC VOL: 0
; 0000 04FE // Perform several offset measurements and store the mean value
; 0000 04FF offs=0;
;PCODE: $000002FD VOL: 0
;PCODE: $000002FE VOL: 0
; 0000 0500 for (i=0; i<16; i++)
;PCODE: $000002FF VOL: 0
;PCODE: $00000300 VOL: 0
;PCODE: $00000301 VOL: 0
;PCODE: $00000302 VOL: 0
;PCODE: $00000303 VOL: 0
;PCODE: $00000304 VOL: 0
;PCODE: $00000305 VOL: 0
;PCODE: $00000306 VOL: 0
;PCODE: $00000307 VOL: 0
; 0000 0501     {
; 0000 0502     // Start the AD conversion on channel 0
; 0000 0503     ADCA.CH0.CTRL|=ADC_CH_START_bm;
;PCODE: $00000308 VOL: 1
;PCODE: $00000309 VOL: 0
;PCODE: $0000030A VOL: 1
; 0000 0504     // Wait for the AD conversion to complete
; 0000 0505     while ((ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm)==0);
;PCODE: $0000030B VOL: 0
;PCODE: $0000030C VOL: 1
;PCODE: $0000030D VOL: 0
;PCODE: $0000030E VOL: 0
;PCODE: $0000030F VOL: 0
;PCODE: $00000310 VOL: 0
; 0000 0506     // Clear the interrupt flag
; 0000 0507     ADCA.CH0.INTFLAGS=ADC_CH_CHIF_bm;
;PCODE: $00000311 VOL: 0
;PCODE: $00000312 VOL: 1
; 0000 0508     // Read the offset
; 0000 0509     offs+=(unsigned char) ADCA.CH0.RESL;
;PCODE: $00000313 VOL: 1
;PCODE: $00000314 VOL: 0
;PCODE: $00000315 VOL: 0
;PCODE: $00000316 VOL: 0
; 0000 050A     }
;PCODE: $00000317 VOL: 0
;PCODE: $00000318 VOL: 0
;PCODE: $00000319 VOL: 0
;PCODE: $0000031A VOL: 0
;PCODE: $0000031B VOL: 0
; 0000 050B // Disable the ADC
; 0000 050C ADCA.CTRLA&= ~ADC_ENABLE_bm;
;PCODE: $0000031C VOL: 1
;PCODE: $0000031D VOL: 0
;PCODE: $0000031E VOL: 1
; 0000 050D // Store the mean value of the offset
; 0000 050E adca_offset=(unsigned char) (offs/16);
;PCODE: $0000031F VOL: 0
;PCODE: $00000320 VOL: 0
;PCODE: $00000321 VOL: 0
; 0000 050F 
; 0000 0510 // Initialize the ADC Compare register
; 0000 0511 ADCA.CMPL=0x00;
;PCODE: $00000322 VOL: 0
;PCODE: $00000323 VOL: 1
; 0000 0512 ADCA.CMPH=0x00;
;PCODE: $00000324 VOL: 0
;PCODE: $00000325 VOL: 1
; 0000 0513 
; 0000 0514 // ADC channel 0 gain: 1
; 0000 0515 // ADC channel 0 input mode: Single-ended positive input signal
; 0000 0516 ADCA.CH0.CTRL=(ADCA.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAINFAC_gm | ADC_CH_INPUTMODE_gm))) |
; 0000 0517 	ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
;PCODE: $00000326 VOL: 1
;PCODE: $00000327 VOL: 0
;PCODE: $00000328 VOL: 0
;PCODE: $00000329 VOL: 0
;PCODE: $0000032A VOL: 1
; 0000 0518 
; 0000 0519 // ADC channel 0 positive input: ADC2 pin
; 0000 051A // ADC channel 0 negative input: GND
; 0000 051B ADCA.CH0.MUXCTRL=(ADCA.CH0.MUXCTRL & (~(ADC_CH_MUXPOS_gm | ADC_CH_MUXNEG_gm))) |
; 0000 051C 	ADC_CH_MUXPOS_PIN2_gc;
;PCODE: $0000032B VOL: 1
;PCODE: $0000032C VOL: 0
;PCODE: $0000032D VOL: 0
;PCODE: $0000032E VOL: 1
; 0000 051D 
; 0000 051E // ADC channel 1 gain: 1
; 0000 051F // ADC channel 1 input mode: Single-ended positive input signal
; 0000 0520 ADCA.CH1.CTRL=(ADCA.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAINFAC_gm | ADC_CH_INPUTMODE_gm))) |
; 0000 0521 	ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
;PCODE: $0000032F VOL: 1
;PCODE: $00000330 VOL: 0
;PCODE: $00000331 VOL: 0
;PCODE: $00000332 VOL: 0
;PCODE: $00000333 VOL: 1
; 0000 0522 
; 0000 0523 // ADC channel 1 positive input: ADC3 pin
; 0000 0524 // ADC channel 1 negative input: GND
; 0000 0525 ADCA.CH1.MUXCTRL=(ADCA.CH1.MUXCTRL & (~(ADC_CH_MUXPOS_gm | ADC_CH_MUXNEG_gm))) |
; 0000 0526 	ADC_CH_MUXPOS_PIN3_gc;
;PCODE: $00000334 VOL: 1
;PCODE: $00000335 VOL: 0
;PCODE: $00000336 VOL: 0
;PCODE: $00000337 VOL: 1
; 0000 0527 
; 0000 0528 // ADC channel 2 gain: 1
; 0000 0529 // ADC channel 2 input mode: Internal positive input signal
; 0000 052A ADCA.CH2.CTRL=(ADCA.CH2.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAINFAC_gm | ADC_CH_INPUTMODE_gm))) |
; 0000 052B 	ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
;PCODE: $00000338 VOL: 1
;PCODE: $00000339 VOL: 0
;PCODE: $0000033A VOL: 0
;PCODE: $0000033B VOL: 0
;PCODE: $0000033C VOL: 1
; 0000 052C 
; 0000 052D // ADC channel 2 positive input: Temp. Reference
; 0000 052E // ADC channel 2 negative input: GND
; 0000 052F ADCA.CH2.MUXCTRL=(ADCA.CH2.MUXCTRL & (~(ADC_CH_MUXPOS_gm | ADC_CH_MUXNEG_gm))) |
; 0000 0530 	ADC_CH_MUXINT_TEMP_gc;
;PCODE: $0000033D VOL: 1
;PCODE: $0000033E VOL: 0
;PCODE: $0000033F VOL: 0
;PCODE: $00000340 VOL: 1
; 0000 0531 
; 0000 0532 // ADC channel 3 gain: 1
; 0000 0533 // ADC channel 3 input mode: Internal positive input signal
; 0000 0534 ADCA.CH3.CTRL=(ADCA.CH3.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAINFAC_gm | ADC_CH_INPUTMODE_gm))) |
; 0000 0535 	ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
;PCODE: $00000341 VOL: 1
;PCODE: $00000342 VOL: 0
;PCODE: $00000343 VOL: 0
;PCODE: $00000344 VOL: 0
;PCODE: $00000345 VOL: 1
; 0000 0536 
; 0000 0537 // ADC channel 3 positive input: Temp. Reference
; 0000 0538 // ADC channel 3 negative input: GND
; 0000 0539 ADCA.CH3.MUXCTRL=(ADCA.CH3.MUXCTRL & (~(ADC_CH_MUXPOS_gm | ADC_CH_MUXNEG_gm))) |
; 0000 053A 	ADC_CH_MUXINT_TEMP_gc;
;PCODE: $00000346 VOL: 1
;PCODE: $00000347 VOL: 0
;PCODE: $00000348 VOL: 0
;PCODE: $00000349 VOL: 1
; 0000 053B 
; 0000 053C // AD conversion is started by software
; 0000 053D ADCA.EVCTRL=ADC_EVACT_NONE_gc;
;PCODE: $0000034A VOL: 0
;PCODE: $0000034B VOL: 1
; 0000 053E 
; 0000 053F // Channel 0 interrupt: Disabled
; 0000 0540 ADCA.CH0.INTCTRL=(ADCA.CH0.INTCTRL & (~(ADC_CH_INTMODE_gm | ADC_CH_INTLVL_gm))) |
; 0000 0541 	ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
;PCODE: $0000034C VOL: 1
;PCODE: $0000034D VOL: 0
;PCODE: $0000034E VOL: 0
;PCODE: $0000034F VOL: 0
;PCODE: $00000350 VOL: 1
; 0000 0542 // Channel 1 interrupt: Disabled
; 0000 0543 ADCA.CH1.INTCTRL=(ADCA.CH1.INTCTRL & (~(ADC_CH_INTMODE_gm | ADC_CH_INTLVL_gm))) |
; 0000 0544 	ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
;PCODE: $00000351 VOL: 1
;PCODE: $00000352 VOL: 0
;PCODE: $00000353 VOL: 0
;PCODE: $00000354 VOL: 0
;PCODE: $00000355 VOL: 1
; 0000 0545 // Channel 2 interrupt: Disabled
; 0000 0546 ADCA.CH2.INTCTRL=(ADCA.CH2.INTCTRL & (~(ADC_CH_INTMODE_gm | ADC_CH_INTLVL_gm))) |
; 0000 0547 	ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
;PCODE: $00000356 VOL: 1
;PCODE: $00000357 VOL: 0
;PCODE: $00000358 VOL: 0
;PCODE: $00000359 VOL: 0
;PCODE: $0000035A VOL: 1
; 0000 0548 // Channel 3 interrupt: Disabled
; 0000 0549 ADCA.CH3.INTCTRL=(ADCA.CH3.INTCTRL & (~(ADC_CH_INTMODE_gm | ADC_CH_INTLVL_gm))) |
; 0000 054A 	ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
;PCODE: $0000035B VOL: 1
;PCODE: $0000035C VOL: 0
;PCODE: $0000035D VOL: 0
;PCODE: $0000035E VOL: 0
;PCODE: $0000035F VOL: 1
; 0000 054B 
; 0000 054C // Enable the ADC
; 0000 054D ADCA.CTRLA|=ADC_ENABLE_bm;
;PCODE: $00000360 VOL: 1
;PCODE: $00000361 VOL: 0
;PCODE: $00000362 VOL: 1
; 0000 054E // Insert a delay to allow the ADC common mode voltage to stabilize
; 0000 054F delay_us(2);
;PCODE: $00000363 VOL: 0
; 0000 0550 }
;PCODE: $00000364 VOL: 0
;PCODE: $00000365 VOL: 0
;PCODE: $00000366 VOL: 0
;PCODE: $00000367 VOL: 0
;
;// ADCA channel data read function using polled mode
;unsigned int adca_read(unsigned char channel)
; 0000 0554 {
;PCODE: $00000368 VOL: 0
;PCODE: $00000369 VOL: 0
; 0000 0555 ADC_CH_t *pch=&ADCA.CH0+channel;
; 0000 0556 unsigned int data;
; 0000 0557 
; 0000 0558 // Start the AD conversion
; 0000 0559 pch->CTRL|=ADC_CH_START_bm;
;PCODE: $0000036A VOL: 0
;PCODE: $0000036B VOL: 0
;	channel -> Y+4
;	*pch -> R16,R17
;	data -> R18,R19
;PCODE: $0000036C VOL: 0
;PCODE: $0000036D VOL: 0
;PCODE: $0000036E VOL: 1
;PCODE: $0000036F VOL: 0
;PCODE: $00000370 VOL: 0
;PCODE: $00000371 VOL: 0
;PCODE: $00000372 VOL: 0
;PCODE: $00000373 VOL: 0
;PCODE: $00000374 VOL: 0
;PCODE: $00000375 VOL: 0
; 0000 055A // Wait for the AD conversion to complete
; 0000 055B while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
;PCODE: $00000376 VOL: 0
;PCODE: $00000377 VOL: 0
;PCODE: $00000378 VOL: 0
;PCODE: $00000379 VOL: 0
;PCODE: $0000037A VOL: 0
;PCODE: $0000037B VOL: 0
;PCODE: $0000037C VOL: 0
; 0000 055C // Clear the interrupt flag
; 0000 055D pch->INTFLAGS=ADC_CH_CHIF_bm;
;PCODE: $0000037D VOL: 0
;PCODE: $0000037E VOL: 0
;PCODE: $0000037F VOL: 0
;PCODE: $00000380 VOL: 0
; 0000 055E // Read the AD conversion result
; 0000 055F ((unsigned char *) &data)[0]=pch->RESL;
;PCODE: $00000381 VOL: 0
;PCODE: $00000382 VOL: 0
;PCODE: $00000383 VOL: 0
; 0000 0560 ((unsigned char *) &data)[1]=pch->RESH;
;PCODE: $00000384 VOL: 0
;PCODE: $00000385 VOL: 0
;PCODE: $00000386 VOL: 0
; 0000 0561 // Compensate the ADC offset
; 0000 0562 data-=adca_offset;
;PCODE: $00000387 VOL: 0
;PCODE: $00000388 VOL: 0
;PCODE: $00000389 VOL: 0
;PCODE: $0000038A VOL: 0
; 0000 0563 return data;
;PCODE: $0000038B VOL: 0
;PCODE: $0000038C VOL: 0
;PCODE: $0000038D VOL: 0
;PCODE: $0000038E VOL: 0
; 0000 0564 }
;PCODE: $0000038F VOL: 0
;
;// ADCA sweeped channel(s) data read function
;// for software triggered mode
;void adca_sweep_read(unsigned char nch, unsigned int *pdata)
; 0000 0569 {
;PCODE: $00000390 VOL: 0
;PCODE: $00000391 VOL: 0
; 0000 056A ADC_CH_t *pch=&ADCA.CH0;
; 0000 056B unsigned char i,j,m;
; 0000 056C 
; 0000 056D // Sweep starts with channel 0
; 0000 056E j=ADC_CH0START_bm;
;PCODE: $00000392 VOL: 0
;PCODE: $00000393 VOL: 0
;	nch -> Y+8
;	*pdata -> Y+6
;	*pch -> R16,R17
;	i -> R19
;	j -> R18
;	m -> R21
;PCODE: $00000394 VOL: 0
;PCODE: $00000395 VOL: 0
;PCODE: $00000396 VOL: 0
;PCODE: $00000397 VOL: 0
; 0000 056F // Prepare the AD conversion start mask for the sweeped channel(s)
; 0000 0570 m=0;
;PCODE: $00000398 VOL: 0
;PCODE: $00000399 VOL: 0
; 0000 0571 i=0;
;PCODE: $0000039A VOL: 0
;PCODE: $0000039B VOL: 0
; 0000 0572 do
;PCODE: $0000039C VOL: 0
; 0000 0573   {
; 0000 0574   m|=j;
;PCODE: $0000039D VOL: 0
;PCODE: $0000039E VOL: 0
; 0000 0575   j<<=1;
;PCODE: $0000039F VOL: 0
; 0000 0576   }
; 0000 0577 while (++i<nch);
;PCODE: $000003A0 VOL: 0
;PCODE: $000003A1 VOL: 0
;PCODE: $000003A2 VOL: 0
;PCODE: $000003A3 VOL: 0
;PCODE: $000003A4 VOL: 0
;PCODE: $000003A5 VOL: 0
;PCODE: $000003A6 VOL: 0
;PCODE: $000003A7 VOL: 0
; 0000 0578 // Ensure the interrupt flags are cleared
; 0000 0579 ADCA.INTFLAGS=ADCA.INTFLAGS;
;PCODE: $000003A8 VOL: 1
;PCODE: $000003A9 VOL: 1
; 0000 057A // Start the AD conversion for the sweeped channel(s)
; 0000 057B ADCA.CTRLA=(ADCA.CTRLA & (ADC_DMASEL_gm | ADC_FLUSH_bm | ADC_ENABLE_bm)) | m;
;PCODE: $000003AA VOL: 1
;PCODE: $000003AB VOL: 0
;PCODE: $000003AC VOL: 0
;PCODE: $000003AD VOL: 1
; 0000 057C // Read and store the AD conversion results for all the sweeped channels
; 0000 057D for (i=0; i<nch; i++)
;PCODE: $000003AE VOL: 0
;PCODE: $000003AF VOL: 0
;PCODE: $000003B0 VOL: 0
;PCODE: $000003B1 VOL: 0
;PCODE: $000003B2 VOL: 0
;PCODE: $000003B3 VOL: 0
;PCODE: $000003B4 VOL: 0
;PCODE: $000003B5 VOL: 0
;PCODE: $000003B6 VOL: 0
; 0000 057E     {
; 0000 057F     // Wait for the AD conversion to complete
; 0000 0580     while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
;PCODE: $000003B7 VOL: 0
;PCODE: $000003B8 VOL: 0
;PCODE: $000003B9 VOL: 0
;PCODE: $000003BA VOL: 0
;PCODE: $000003BB VOL: 0
;PCODE: $000003BC VOL: 0
;PCODE: $000003BD VOL: 0
; 0000 0581     // Clear the interrupt flag
; 0000 0582     pch->INTFLAGS=ADC_CH_CHIF_bm;
;PCODE: $000003BE VOL: 0
;PCODE: $000003BF VOL: 0
;PCODE: $000003C0 VOL: 0
;PCODE: $000003C1 VOL: 0
; 0000 0583     // Read the AD conversion result
; 0000 0584     ((unsigned char *) pdata)[0]=pch->RESL;
;PCODE: $000003C2 VOL: 0
;PCODE: $000003C3 VOL: 0
;PCODE: $000003C4 VOL: 0
;PCODE: $000003C5 VOL: 0
; 0000 0585     ((unsigned char *) pdata)[1]=pch->RESH;
;PCODE: $000003C6 VOL: 0
;PCODE: $000003C7 VOL: 0
;PCODE: $000003C8 VOL: 0
;PCODE: $000003C9 VOL: 0
; 0000 0586     // Compensate the ADC offset
; 0000 0587     *pdata-=adca_offset;
;PCODE: $000003CA VOL: 0
;PCODE: $000003CB VOL: 0
;PCODE: $000003CC VOL: 0
;PCODE: $000003CD VOL: 0
;PCODE: $000003CE VOL: 0
;PCODE: $000003CF VOL: 0
;PCODE: $000003D0 VOL: 0
;PCODE: $000003D1 VOL: 0
;PCODE: $000003D2 VOL: 0
;PCODE: $000003D3 VOL: 0
; 0000 0588     pdata++;
;PCODE: $000003D4 VOL: 0
;PCODE: $000003D5 VOL: 0
;PCODE: $000003D6 VOL: 0
; 0000 0589     pch++;
;PCODE: $000003D7 VOL: 0
;PCODE: $000003D8 VOL: 0
; 0000 058A     }
;PCODE: $000003D9 VOL: 0
;PCODE: $000003DA VOL: 0
;PCODE: $000003DB VOL: 0
;PCODE: $000003DC VOL: 0
;PCODE: $000003DD VOL: 0
; 0000 058B }
;PCODE: $000003DE VOL: 0
;PCODE: $000003DF VOL: 0
;PCODE: $000003E0 VOL: 0
;PCODE: $000003E1 VOL: 0
;////////////////////////////////////°ª Ãâ·Â/////////////////////////////////////////////////
;void putstring(char *command)
; 0000 058E {
;PCODE: $000003E2 VOL: 0
;PCODE: $000003E3 VOL: 0
; 0000 058F     int i=0;
; 0000 0590     while(*(command+i) !=0)
;PCODE: $000003E4 VOL: 0
;PCODE: $000003E5 VOL: 0
;PCODE: $000003E6 VOL: 0
;	*command -> Y+2
;	i -> R16,R17
;PCODE: $000003E7 VOL: 0
;PCODE: $000003E8 VOL: 0
;PCODE: $000003E9 VOL: 0
;PCODE: $000003EA VOL: 0
;PCODE: $000003EB VOL: 0
;PCODE: $000003EC VOL: 0
;PCODE: $000003ED VOL: 0
;PCODE: $000003EE VOL: 0
;PCODE: $000003EF VOL: 0
; 0000 0591     {
; 0000 0592         putchar(*(command+i));
;PCODE: $000003F0 VOL: 0
;PCODE: $000003F1 VOL: 0
;PCODE: $000003F2 VOL: 0
;PCODE: $000003F3 VOL: 0
;PCODE: $000003F4 VOL: 0
; 0000 0593         putchar_usartd0(*(command+i));
;PCODE: $000003F5 VOL: 0
;PCODE: $000003F6 VOL: 0
;PCODE: $000003F7 VOL: 0
;PCODE: $000003F8 VOL: 0
;PCODE: $000003F9 VOL: 0
; 0000 0594         i++;
;PCODE: $000003FA VOL: 0
;PCODE: $000003FB VOL: 0
; 0000 0595     }
;PCODE: $000003FC VOL: 0
;PCODE: $000003FD VOL: 0
; 0000 0596 }
;PCODE: $000003FE VOL: 0
;PCODE: $000003FF VOL: 0
;PCODE: $00000400 VOL: 0
;PCODE: $00000401 VOL: 0
;PCODE: $00000402 VOL: 0
;PCODE: $00000403 VOL: 0
;PCODE: $00000404 VOL: 0
;
;/***************************************************************¿Â½Àµµ ¼¾¼­************************************************************/
;#define SDA VPORT2_OUT.0
;#define SCL VPORT2_OUT.1
;#define SDA_IN VPORT2_IN.0
;#define SDA_Direction VPORT2_DIR.0
;#define SCL_Direction VPORT2_DIR.1
;#define Delay_1us() delay_us(1)
;
;
;// ¿Â½Àµµ °è»êÀ» À§ÇÑ °íÁ¤ °ª
;const unsigned int C1 = 400;             // -4

	.DSEG
;const unsigned int C2 = 405;             // 0.0405  (405 * 10^-4)
;const unsigned short C3 = 28;            // -2.8 * 10^-6  (28 * 10^-7)
;const unsigned int D1 = 4000;            // -40
;const unsigned short D2 = 1;             // 0.01
;// ¿Â½Àµµ¼¾¼­ º¯¼ö
;unsigned short i, j;
;long int temp, k, SOt, SOrh, Ta_res, Rh_res;
;char Ta[16] = "000.00";//"Ta = 000.00    ";
;char Rh[16] = "000.00";//"Rh = 000.00    ";
;////////////////////////////////////////I2CÅë½Å///////////////////////////////////
;void SHT_Reset() {
; 0000 05AD void SHT_Reset() {

	.CSEG
;PCODE: $00000405 VOL: 0
;PCODE: $00000406 VOL: 0
; 0000 05AE   SCL = 0;                                 // SCL low
;PCODE: $00000407 VOL: 0
;PCODE: $00000408 VOL: 0
; 0000 05AF   SDA_Direction = 0;                  // SDA¸¦ inputÀ¸·Î define
;PCODE: $00000409 VOL: 0
;PCODE: $0000040A VOL: 0
; 0000 05B0   for (i = 1; i <= 18; i++)              // 18¹ø ¹Ýº¹ÇÏ¿© 9¹ø Å¬·°À» ¸¸µë(9¹øÀÇ Å¬·°µ¿¾È SDA°¡ 1À» À¯ÁöÇÏ¸é ¸®¼Â)
;PCODE: $0000040B VOL: 0
;PCODE: $0000040C VOL: 0
;PCODE: $0000040D VOL: 0
;PCODE: $0000040E VOL: 0
;PCODE: $0000040F VOL: 0
;PCODE: $00000410 VOL: 0
;PCODE: $00000411 VOL: 0
;PCODE: $00000412 VOL: 0
;PCODE: $00000413 VOL: 0
;PCODE: $00000414 VOL: 0
; 0000 05B1     {
; 0000 05B2     SCL = ~SCL;
;PCODE: $00000415 VOL: 0
;PCODE: $00000416 VOL: 0
;PCODE: $00000417 VOL: 0
;PCODE: $00000418 VOL: 0
;PCODE: $00000419 VOL: 0
;PCODE: $0000041A VOL: 0
;PCODE: $0000041B VOL: 0
;PCODE: $0000041C VOL: 0
;PCODE: $0000041D VOL: 0
;PCODE: $0000041E VOL: 0
; 0000 05B3     //Delay_1us();
; 0000 05B4     }
;PCODE: $0000041F VOL: 0
;PCODE: $00000420 VOL: 0
;PCODE: $00000421 VOL: 0
;PCODE: $00000422 VOL: 0
;PCODE: $00000423 VOL: 0
;PCODE: $00000424 VOL: 0
; 0000 05B5 }
;PCODE: $00000425 VOL: 0
;PCODE: $00000426 VOL: 0
;void Transmission_Start() {
; 0000 05B6 void Transmission_Start() {
;PCODE: $00000427 VOL: 0
;PCODE: $00000428 VOL: 0
; 0000 05B7   SDA_Direction = 0;                     // SDA¸¦ inputÀ¸·Î define
;PCODE: $00000429 VOL: 0
;PCODE: $0000042A VOL: 0
; 0000 05B8   SCL = 1;                               // SCL high
;PCODE: $0000042B VOL: 0
;PCODE: $0000042C VOL: 0
; 0000 05B9   Delay_1us();                           // 1us delay
;PCODE: $0000042D VOL: 0
; 0000 05BA   SDA_Direction = 1;                     // SDA¸¦ outputÀ¸·Î define
;PCODE: $0000042E VOL: 0
;PCODE: $0000042F VOL: 0
; 0000 05BB   SDA = 0;                               // SDA low
;PCODE: $00000430 VOL: 0
;PCODE: $00000431 VOL: 0
; 0000 05BC   Delay_1us();                           // 1us delay
;PCODE: $00000432 VOL: 0
; 0000 05BD   SCL = 0;                               // SCL low
;PCODE: $00000433 VOL: 0
;PCODE: $00000434 VOL: 0
; 0000 05BE   Delay_1us();                           // 1us delay
;PCODE: $00000435 VOL: 0
; 0000 05BF   SCL = 1;                               // SCL high
;PCODE: $00000436 VOL: 0
;PCODE: $00000437 VOL: 0
; 0000 05C0   Delay_1us();                           // 1us delay
;PCODE: $00000438 VOL: 0
; 0000 05C1   SDA_Direction = 0;                     // SDA¸¦ inputÀ¸·Î define
;PCODE: $00000439 VOL: 0
;PCODE: $0000043A VOL: 0
; 0000 05C2   Delay_1us();                           // 1us delay
;PCODE: $0000043B VOL: 0
; 0000 05C3   SCL = 0;                               // SCL low
;PCODE: $0000043C VOL: 0
;PCODE: $0000043D VOL: 0
; 0000 05C4 }
;PCODE: $0000043E VOL: 0
;PCODE: $0000043F VOL: 0
;// MCU ACKÀÀ´ä
;void MCU_ACK() {
; 0000 05C6 void MCU_ACK() {
;PCODE: $00000440 VOL: 0
;PCODE: $00000441 VOL: 0
; 0000 05C7   SDA_Direction = 1;     // SDA¸¦ outputÀ¸·Î define
;PCODE: $00000442 VOL: 0
;PCODE: $00000443 VOL: 0
; 0000 05C8   SDA = 0;               // SDA low
;PCODE: $00000444 VOL: 0
;PCODE: $00000445 VOL: 0
; 0000 05C9   SCL = 1;               // SCL high
;PCODE: $00000446 VOL: 0
;PCODE: $00000447 VOL: 0
; 0000 05CA   Delay_1us();           // 1us delay
;PCODE: $00000448 VOL: 0
; 0000 05CB   SCL = 0;               // SCL low
;PCODE: $00000449 VOL: 0
;PCODE: $0000044A VOL: 0
; 0000 05CC   Delay_1us();           // 1us delay
;PCODE: $0000044B VOL: 0
; 0000 05CD   SDA_Direction = 0;     // SDA¸¦ inputÀ¸·Î define
;PCODE: $0000044C VOL: 0
;PCODE: $0000044D VOL: 0
; 0000 05CE }
;PCODE: $0000044E VOL: 0
;PCODE: $0000044F VOL: 0
;// command¿¡ µû¸¥ ¿Âµµ or ½Àµµ ÃøÁ¤ ÇÔ¼ö
;long int Measure(short num) {
; 0000 05D0 long int Measure(short num) {
;PCODE: $00000450 VOL: 0
;PCODE: $00000451 VOL: 0
; 0000 05D1   j = num;                           // j = command (0x03 : ¿Âµµ or 0x05 : ½Àµµ)
;PCODE: $00000452 VOL: 0
;	num -> Y+0
;PCODE: $00000453 VOL: 0
;PCODE: $00000454 VOL: 0
; 0000 05D2   SHT_Reset();                       // ¼¾¼­ ¸®¼Â ÀýÂ÷
;PCODE: $00000455 VOL: 0
; 0000 05D3   Transmission_Start();              // Àü¼Û ½ÃÀÛ ÀýÂ÷
;PCODE: $00000456 VOL: 0
; 0000 05D4   k = 0;                             // k = 0
;PCODE: $00000457 VOL: 0
;PCODE: $00000458 VOL: 0
; 0000 05D5   SDA_Direction = 1;                 // SDA¸¦ outputÀ¸·Î define
;PCODE: $00000459 VOL: 0
;PCODE: $0000045A VOL: 0
; 0000 05D6   SCL = 0;                           // SCL low
;PCODE: $0000045B VOL: 0
;PCODE: $0000045C VOL: 0
; 0000 05D7   for(i = 1; i <= 8; i++) {          // 8¹ø ¹Ýº¹
;PCODE: $0000045D VOL: 0
;PCODE: $0000045E VOL: 0
;PCODE: $0000045F VOL: 0
;PCODE: $00000460 VOL: 0
;PCODE: $00000461 VOL: 0
;PCODE: $00000462 VOL: 0
;PCODE: $00000463 VOL: 0
;PCODE: $00000464 VOL: 0
;PCODE: $00000465 VOL: 0
;PCODE: $00000466 VOL: 0
; 0000 05D8     if(j & 0x80)              //if (j.F7 == 1)                   // if bit 7 = 1
;PCODE: $00000467 VOL: 0
;PCODE: $00000468 VOL: 0
;PCODE: $00000469 VOL: 0
; 0000 05D9     SDA_Direction = 0;              // SDA¸¦ inputÀ¸·Î define
;PCODE: $0000046A VOL: 0
;PCODE: $0000046B VOL: 0
; 0000 05DA 
; 0000 05DB     else {                           // else (if bit 7 = 0)
;PCODE: $0000046C VOL: 0
;PCODE: $0000046D VOL: 0
; 0000 05DC      SDA_Direction = 1;              // SDA¸¦ outputÀ¸·Î define
;PCODE: $0000046E VOL: 0
;PCODE: $0000046F VOL: 0
; 0000 05DD      SDA = 0;                        // SDA low
;PCODE: $00000470 VOL: 0
;PCODE: $00000471 VOL: 0
; 0000 05DE    }
;PCODE: $00000472 VOL: 0
; 0000 05DF     Delay_1us();                     // 1us delay
;PCODE: $00000473 VOL: 0
; 0000 05E0     SCL = 1;                         // SCL high
;PCODE: $00000474 VOL: 0
;PCODE: $00000475 VOL: 0
; 0000 05E1     Delay_1us();                     // 1us delay
;PCODE: $00000476 VOL: 0
; 0000 05E2     SCL = 0;                         // SCL low
;PCODE: $00000477 VOL: 0
;PCODE: $00000478 VOL: 0
; 0000 05E3     j <<= 1;                         // jÀÇ ³»¿ëÀ» ÇÑÄ­ ¿ÞÂÊÀ¸·Î ½ÃÇÁÆ®
;PCODE: $00000479 VOL: 0
;PCODE: $0000047A VOL: 0
;PCODE: $0000047B VOL: 0
; 0000 05E4   }
;PCODE: $0000047C VOL: 0
;PCODE: $0000047D VOL: 0
;PCODE: $0000047E VOL: 0
;PCODE: $0000047F VOL: 0
;PCODE: $00000480 VOL: 0
;PCODE: $00000481 VOL: 0
; 0000 05E5 
; 0000 05E6   SDA_Direction = 0;                 // SDA¸¦ inputÀ¸·Î define
;PCODE: $00000482 VOL: 0
;PCODE: $00000483 VOL: 0
; 0000 05E7   SCL = 1;                           // SCL high
;PCODE: $00000484 VOL: 0
;PCODE: $00000485 VOL: 0
; 0000 05E8   Delay_1us();                       // 1us delay
;PCODE: $00000486 VOL: 0
; 0000 05E9   SCL = 0;                           // SCL low
;PCODE: $00000487 VOL: 0
;PCODE: $00000488 VOL: 0
; 0000 05EA   Delay_1us();                       // 1us delay
;PCODE: $00000489 VOL: 0
; 0000 05EB   while (SDA_IN == 1)                // SDA°¡ high ÀÏ¶§µ¿¾È µ¿ÀÛX
;PCODE: $0000048A VOL: 0
;PCODE: $0000048B VOL: 0
;PCODE: $0000048C VOL: 0
;PCODE: $0000048D VOL: 0
; 0000 05EC     Delay_1us();                     // 1us delay
;PCODE: $0000048E VOL: 0
;PCODE: $0000048F VOL: 0
;PCODE: $00000490 VOL: 0
; 0000 05ED for (i = 1; i <=16; i++) {
;PCODE: $00000491 VOL: 0
;PCODE: $00000492 VOL: 0
;PCODE: $00000493 VOL: 0
;PCODE: $00000494 VOL: 0
;PCODE: $00000495 VOL: 0
;PCODE: $00000496 VOL: 0
;PCODE: $00000497 VOL: 0
;PCODE: $00000498 VOL: 0
;PCODE: $00000499 VOL: 0
;PCODE: $0000049A VOL: 0
; 0000 05EE     k <<= 1;                         // kÀÇ ³»¿ëÀ» ÇÑÄ­ ¿ÞÂÊÀ¸·Î ½ÃÇÁÆ®
;PCODE: $0000049B VOL: 0
;PCODE: $0000049C VOL: 0
;PCODE: $0000049D VOL: 0
; 0000 05EF     SCL = 1;                         // SCL high
;PCODE: $0000049E VOL: 0
;PCODE: $0000049F VOL: 0
; 0000 05F0     if (SDA_IN == 1)                 // if SDA is high
;PCODE: $000004A0 VOL: 0
;PCODE: $000004A1 VOL: 0
;PCODE: $000004A2 VOL: 0
; 0000 05F1     k = k | 0x0001;
;PCODE: $000004A3 VOL: 0
;PCODE: $000004A4 VOL: 0
;PCODE: $000004A5 VOL: 0
; 0000 05F2     SCL = 0;
;PCODE: $000004A6 VOL: 0
;PCODE: $000004A7 VOL: 0
;PCODE: $000004A8 VOL: 0
; 0000 05F3     if (i == 8)                      // if counter i = 8 ÀÏ¶§
;PCODE: $000004A9 VOL: 0
;PCODE: $000004AA VOL: 0
;PCODE: $000004AB VOL: 0
; 0000 05F4       MCU_ACK();                     // MCU ÀÀ´ä
;PCODE: $000004AC VOL: 0
; 0000 05F5   }
;PCODE: $000004AD VOL: 0
;PCODE: $000004AE VOL: 0
;PCODE: $000004AF VOL: 0
;PCODE: $000004B0 VOL: 0
;PCODE: $000004B1 VOL: 0
;PCODE: $000004B2 VOL: 0
;PCODE: $000004B3 VOL: 0
; 0000 05F6 
; 0000 05F7   return k;                          // KÀ» ¸®ÅÏ
;PCODE: $000004B4 VOL: 0
;PCODE: $000004B5 VOL: 0
;PCODE: $000004B6 VOL: 0
; 0000 05F8 }
;PCODE: $000004B7 VOL: 0
;
;//////////////////////////////////////ÃøÁ¤°ü·ÃÇÔ¼ö//////////////////////////////////////////////
;// ÃøÁ¤ ¹× °è»ê
;void calculation(void){
; 0000 05FC void calculation(void){
;PCODE: $000004B8 VOL: 0
;PCODE: $000004B9 VOL: 0
; 0000 05FD     // ¿Âµµ ÃøÁ¤
; 0000 05FE     SOt = Measure(0x03);             // ÃøÁ¤ÇÔ¼ö (command 0x03 : ¿Âµµ)
;PCODE: $000004BA VOL: 0
;PCODE: $000004BB VOL: 0
;PCODE: $000004BC VOL: 0
;PCODE: $000004BD VOL: 0
; 0000 05FF      // ½Àµµ ÃøÁ¤
; 0000 0600     SOrh = Measure(0x05);            // ÃøÁ¤ÇÔ¼ö (command 0x05 : ½Àµµ)
;PCODE: $000004BE VOL: 0
;PCODE: $000004BF VOL: 0
;PCODE: $000004C0 VOL: 0
;PCODE: $000004C1 VOL: 0
; 0000 0601 
; 0000 0602     // ¿Âµµ °è»ê
; 0000 0603     // Ta_res = D1 + D2 * SOt
; 0000 0604     if(SOt > D1)                     // ¿Âµµ°¡ ¿µ»óÀÌ¸é
;PCODE: $000004C2 VOL: 0
;PCODE: $000004C3 VOL: 0
;PCODE: $000004C4 VOL: 0
; 0000 0605       Ta_res = SOt * D2 - D1;        // ¿µ»ó ¿Âµµ °è»ê
;PCODE: $000004C5 VOL: 0
;PCODE: $000004C6 VOL: 0
;PCODE: $000004C7 VOL: 0
; 0000 0606     else                             // ¿Âµµ°¡ ¿µÇÏÀÌ¸é
;PCODE: $000004C8 VOL: 0
;PCODE: $000004C9 VOL: 0
; 0000 0607       Ta_res = D1 - SOt * D2;        // ¿µÇÏ ¿Âµµ °è»ê
;PCODE: $000004CA VOL: 0
;PCODE: $000004CB VOL: 0
;PCODE: $000004CC VOL: 0
;PCODE: $000004CD VOL: 0
; 0000 0608 
; 0000 0609     // ½Àµµ °è»ê
; 0000 060A     // Rh_res = C1 + C2 * SOrh + C3 * SOrh^2
; 0000 060B     temp = SOrh * SOrh * C3 / 100000;             // ½Àµµ°è»ê°úÁ¤
;PCODE: $000004CE VOL: 0
;PCODE: $000004CF VOL: 0
;PCODE: $000004D0 VOL: 0
;PCODE: $000004D1 VOL: 0
;PCODE: $000004D2 VOL: 0
;PCODE: $000004D3 VOL: 0
;PCODE: $000004D4 VOL: 0
;PCODE: $000004D5 VOL: 0
;PCODE: $000004D6 VOL: 0
;PCODE: $000004D7 VOL: 0
; 0000 060C     Rh_res = SOrh * C2 / 100 - temp - C1;         //
;PCODE: $000004D8 VOL: 0
;PCODE: $000004D9 VOL: 0
;PCODE: $000004DA VOL: 0
;PCODE: $000004DB VOL: 0
;PCODE: $000004DC VOL: 0
;PCODE: $000004DD VOL: 0
;PCODE: $000004DE VOL: 0
;PCODE: $000004DF VOL: 0
;PCODE: $000004E0 VOL: 0
;PCODE: $000004E1 VOL: 0
;PCODE: $000004E2 VOL: 0
; 0000 060D 
; 0000 060E }
;PCODE: $000004E3 VOL: 0
;PCODE: $000004E4 VOL: 0
;// °è»ê°ª ÀÚ¸®¼ö
;void calculation_res(char value[], long int res){
; 0000 0610 void calculation_res(char value[], long int res){
;PCODE: $000004E5 VOL: 0
;PCODE: $000004E6 VOL: 0
; 0000 0611     value[0] = res / 10000 + 48;                    // example: Ta[5] = 12345 / 10000 = 1, 1 + 48 = '1' - ASCII
;PCODE: $000004E7 VOL: 0
;	value -> Y+4
;	res -> Y+0
;PCODE: $000004E8 VOL: 0
;PCODE: $000004E9 VOL: 0
;PCODE: $000004EA VOL: 0
;PCODE: $000004EB VOL: 0
;PCODE: $000004EC VOL: 0
;PCODE: $000004ED VOL: 0
; 0000 0612     value[1] = res % 10000 / 1000 + 48;        // example: Ta[6] = 12345 % 10000 = 2345, Ta[6] = 2345 / 1000 = 2, 2 + 48 = '2' - ASCII
;PCODE: $000004EE VOL: 0
;PCODE: $000004EF VOL: 0
;PCODE: $000004F0 VOL: 0
;PCODE: $000004F1 VOL: 0
;PCODE: $000004F2 VOL: 0
;PCODE: $000004F3 VOL: 0
;PCODE: $000004F4 VOL: 0
;PCODE: $000004F5 VOL: 0
;PCODE: $000004F6 VOL: 0
; 0000 0613     value[2] = res % 1000 / 100 + 48;            // example: Ta[7] = 12345 % 1000 = 345, Ta[7] = 345 / 100 = 3, 3 + 48 = '3' - ASCII
;PCODE: $000004F7 VOL: 0
;PCODE: $000004F8 VOL: 0
;PCODE: $000004F9 VOL: 0
;PCODE: $000004FA VOL: 0
;PCODE: $000004FB VOL: 0
;PCODE: $000004FC VOL: 0
;PCODE: $000004FD VOL: 0
;PCODE: $000004FE VOL: 0
;PCODE: $000004FF VOL: 0
; 0000 0614     value[4] = res % 100 / 10 + 48;                // example: Ta[9] = 12345 % 100 = 45, Ta[9] = 45 / 10 = 4, 4 + 48 = '4' - ASCII
;PCODE: $00000500 VOL: 0
;PCODE: $00000501 VOL: 0
;PCODE: $00000502 VOL: 0
;PCODE: $00000503 VOL: 0
;PCODE: $00000504 VOL: 0
;PCODE: $00000505 VOL: 0
;PCODE: $00000506 VOL: 0
;PCODE: $00000507 VOL: 0
;PCODE: $00000508 VOL: 0
; 0000 0615     value[5] = res % 10 + 48;                       // example: Ta[10] = 12345 % 10 = 5, 5 + 48 = '5' - ASCII
;PCODE: $00000509 VOL: 0
;PCODE: $0000050A VOL: 0
;PCODE: $0000050B VOL: 0
;PCODE: $0000050C VOL: 0
;PCODE: $0000050D VOL: 0
;PCODE: $0000050E VOL: 0
; 0000 0616 // ¸Ç ¾ÕÀÚ¸®¼ö 0ÀÏ¶§ ºóÄ­ ÀÔ·Â
; 0000 0617     if (value[0] == '0')                                  // Ta[5] = '0' ÀÏ ¶§
;PCODE: $0000050F VOL: 0
;PCODE: $00000510 VOL: 0
;PCODE: $00000511 VOL: 0
;PCODE: $00000512 VOL: 0
; 0000 0618       value[0] = ' ';                                           // Ta[5]¿¡ ºóÄ­ ÀÔ·Â
;PCODE: $00000513 VOL: 0
;PCODE: $00000514 VOL: 0
;PCODE: $00000515 VOL: 0
; 0000 0619     if (value[0] == ' ' && value[1] == '0')        // Ta[5]°¡ ºóÄ­ÀÌ°í Ta[6]°¡ '0' ÀÏ ¶§
;PCODE: $00000516 VOL: 0
;PCODE: $00000517 VOL: 0
;PCODE: $00000518 VOL: 0
;PCODE: $00000519 VOL: 0
;PCODE: $0000051A VOL: 0
;PCODE: $0000051B VOL: 0
;PCODE: $0000051C VOL: 0
;PCODE: $0000051D VOL: 0
;PCODE: $0000051E VOL: 0
;PCODE: $0000051F VOL: 0
;PCODE: $00000520 VOL: 0
;PCODE: $00000521 VOL: 0
;PCODE: $00000522 VOL: 0
;PCODE: $00000523 VOL: 0
; 0000 061A       value[0] = ' ';                                           // Ta[6]¿¡ ºóÄ­ ÀÔ·Â
;PCODE: $00000524 VOL: 0
;PCODE: $00000525 VOL: 0
;PCODE: $00000526 VOL: 0
; 0000 061B }
;PCODE: $00000527 VOL: 0
;PCODE: $00000528 VOL: 0
;PCODE: $00000529 VOL: 0
;PCODE: $0000052A VOL: 0
;// ÀÛµ¿
;void SHToperation(){
; 0000 061D void SHToperation(){
;PCODE: $0000052B VOL: 0
;PCODE: $0000052C VOL: 0
; 0000 061E     calculation();
;PCODE: $0000052D VOL: 0
; 0000 061F     calculation_res(Ta, Ta_res);
;PCODE: $0000052E VOL: 0
;PCODE: $0000052F VOL: 0
;PCODE: $00000530 VOL: 0
;PCODE: $00000531 VOL: 0
; 0000 0620     calculation_res(Rh, Rh_res);
;PCODE: $00000532 VOL: 0
;PCODE: $00000533 VOL: 0
;PCODE: $00000534 VOL: 0
;PCODE: $00000535 VOL: 0
; 0000 0621     // ¿Â½Àµµ°ª Ãâ·Â
; 0000 0622     putstring(Ta);                            // display temperature on first row, i column
;PCODE: $00000536 VOL: 0
;PCODE: $00000537 VOL: 0
; 0000 0623     putchar(',');
;PCODE: $00000538 VOL: 0
;PCODE: $00000539 VOL: 0
; 0000 0624     putchar_usartd0(',');
;PCODE: $0000053A VOL: 0
;PCODE: $0000053B VOL: 0
; 0000 0625     putstring(Rh);
;PCODE: $0000053C VOL: 0
;PCODE: $0000053D VOL: 0
; 0000 0626 }
;PCODE: $0000053E VOL: 0
;PCODE: $0000053F VOL: 0
;/************************************¸ÕÁö¼¾¼­**************************************/
;unsigned int val0;
;int dustDensity;
;void adc_dust(){
; 0000 062A void adc_dust(){
;PCODE: $00000540 VOL: 0
;PCODE: $00000541 VOL: 0
; 0000 062B     VPORT3_DIR.0 = 1;   // out
;PCODE: $00000542 VOL: 0
;PCODE: $00000543 VOL: 0
; 0000 062C     VPORT3_OUT.0 = 1;   // 3.3VÃâ·Â
;PCODE: $00000544 VOL: 0
;PCODE: $00000545 VOL: 0
; 0000 062D     val0 = adca_read(0);
;PCODE: $00000546 VOL: 0
;PCODE: $00000547 VOL: 0
;PCODE: $00000548 VOL: 0
; 0000 062E     VPORT3_DIR.0 = 1;   // out
;PCODE: $00000549 VOL: 0
;PCODE: $0000054A VOL: 0
; 0000 062F     VPORT3_OUT.0 = 0;   // 0VÃâ·Â
;PCODE: $0000054B VOL: 0
;PCODE: $0000054C VOL: 0
; 0000 0630     //calcvolt0 = 170*val0(3.3/4096)-100 = 0.137*val0-100
; 0000 0631     dustDensity=(int)(0.137*val0-100);
;PCODE: $0000054D VOL: 0
;PCODE: $0000054E VOL: 0
;PCODE: $0000054F VOL: 0
;PCODE: $00000550 VOL: 0
;PCODE: $00000551 VOL: 0
;PCODE: $00000552 VOL: 0
;PCODE: $00000553 VOL: 0
;PCODE: $00000554 VOL: 0
;PCODE: $00000555 VOL: 0
;PCODE: $00000556 VOL: 0
; 0000 0632     if(dustDensity <0) dustDensity=0;
;PCODE: $00000557 VOL: 0
;PCODE: $00000558 VOL: 0
;PCODE: $00000559 VOL: 0
;PCODE: $0000055A VOL: 0
;PCODE: $0000055B VOL: 0
; 0000 0633 }
;PCODE: $0000055C VOL: 0
;PCODE: $0000055D VOL: 0
;PCODE: $0000055E VOL: 0
;
;/***********************************°ø±âÇ°Áú****************************************/
;#define MQ135_DEFAULTPPM 392 //default ppm of CO2 for calibration
;#define MQ135_DEFAULTRO 41763 //default Ro for MQ135_DEFAULTPPM ppm of CO2
;#define MQ135_SCALINGFACTOR 116.602//0682 //CO2 gas value
;#define MQ135_EXPONENT -2.769//034857 //CO2 gas value
;#define MQ135_MAXRSRO 2.428 //for CO2
;#define MQ135_MINRSRO 0.358 //for CO2
;//define mq135 pulldown resistor
;#define MQ135_PULLDOWNRES 18460
;char printbuff[100];
;float d = 0;
;int val1;
;long mq135_ro = 0;
;/*
; * get the calibrated ro based upon read resistance, and a know ppm
; */
;long mq135_getro(long resvalue, float ppm) {
; 0000 0645 long mq135_getro(long resvalue, float ppm) {
;PCODE: $0000055F VOL: 0
;PCODE: $00000560 VOL: 0
; 0000 0646 	return (long)(resvalue * exp( log(MQ135_SCALINGFACTOR/ppm) / MQ135_EXPONENT )); // Rs*exp(log(Scalingfactor / defaultppm) / exponent
;PCODE: $00000561 VOL: 0
;	resvalue -> Y+4
;	ppm -> Y+0
;PCODE: $00000562 VOL: 0
;PCODE: $00000563 VOL: 0
;PCODE: $00000564 VOL: 0
;PCODE: $00000565 VOL: 0
;PCODE: $00000566 VOL: 0
;PCODE: $00000567 VOL: 0
;PCODE: $00000568 VOL: 0
;PCODE: $00000569 VOL: 0
;PCODE: $0000056A VOL: 0
;PCODE: $0000056B VOL: 0
;PCODE: $0000056C VOL: 0
;PCODE: $0000056D VOL: 0
;PCODE: $0000056E VOL: 0
;PCODE: $0000056F VOL: 0
;PCODE: $00000570 VOL: 0
;PCODE: $00000571 VOL: 0
; 0000 0647 }
;PCODE: $00000572 VOL: 0
;
;/*
; * get the ppm concentration
; */
; float mq135_getppm(long resvalue, long ro) {
; 0000 064C float mq135_getppm(long resvalue, long ro) {
;PCODE: $00000573 VOL: 0
;PCODE: $00000574 VOL: 0
; 0000 064D 	float ret = 0;
; 0000 064E 	float validinterval = 0;
; 0000 064F 	validinterval = resvalue/(float)ro;
;PCODE: $00000575 VOL: 0
;PCODE: $00000576 VOL: 0
;PCODE: $00000577 VOL: 0
;PCODE: $00000578 VOL: 0
;PCODE: $00000579 VOL: 0
;PCODE: $0000057A VOL: 0
;PCODE: $0000057B VOL: 0
;PCODE: $0000057C VOL: 0
;PCODE: $0000057D VOL: 0
;PCODE: $0000057E VOL: 0
;PCODE: $0000057F VOL: 0
;PCODE: $00000580 VOL: 0
;PCODE: $00000581 VOL: 0
;PCODE: $00000582 VOL: 0
;PCODE: $00000583 VOL: 0
;PCODE: $00000584 VOL: 0
;PCODE: $00000585 VOL: 0
;PCODE: $00000586 VOL: 0
;	resvalue -> Y+12
;	ro -> Y+8
;	ret -> Y+4
;	validinterval -> Y+0
;PCODE: $00000587 VOL: 0
;PCODE: $00000588 VOL: 0
;PCODE: $00000589 VOL: 0
;PCODE: $0000058A VOL: 0
;PCODE: $0000058B VOL: 0
;PCODE: $0000058C VOL: 0
; 0000 0650 	if(validinterval<MQ135_MAXRSRO && validinterval>MQ135_MINRSRO) {
;PCODE: $0000058D VOL: 0
;PCODE: $0000058E VOL: 0
;PCODE: $0000058F VOL: 0
;PCODE: $00000590 VOL: 0
;PCODE: $00000591 VOL: 0
;PCODE: $00000592 VOL: 0
;PCODE: $00000593 VOL: 0
;PCODE: $00000594 VOL: 0
;PCODE: $00000595 VOL: 0
;PCODE: $00000596 VOL: 0
;PCODE: $00000597 VOL: 0
;PCODE: $00000598 VOL: 0
; 0000 0651 		ret = (float)MQ135_SCALINGFACTOR * pow( ((float)resvalue/ro), MQ135_EXPONENT);
;PCODE: $00000599 VOL: 0
;PCODE: $0000059A VOL: 0
;PCODE: $0000059B VOL: 0
;PCODE: $0000059C VOL: 0
;PCODE: $0000059D VOL: 0
;PCODE: $0000059E VOL: 0
;PCODE: $0000059F VOL: 0
;PCODE: $000005A0 VOL: 0
;PCODE: $000005A1 VOL: 0
;PCODE: $000005A2 VOL: 0
;PCODE: $000005A3 VOL: 0
;PCODE: $000005A4 VOL: 0
; 0000 0652 	}
; 0000 0653 	return ret;
;PCODE: $000005A5 VOL: 0
;PCODE: $000005A6 VOL: 0
;PCODE: $000005A7 VOL: 0
;PCODE: $000005A8 VOL: 0
; 0000 0654 }
;PCODE: $000005A9 VOL: 0
;
;long adc_getresistence(int adcread, long adcbalanceresistor)
; 0000 0657 {
;PCODE: $000005AA VOL: 0
;PCODE: $000005AB VOL: 0
; 0000 0658 	if(adcread == 0)
;PCODE: $000005AC VOL: 0
;	adcread -> Y+4
;	adcbalanceresistor -> Y+0
;PCODE: $000005AD VOL: 0
;PCODE: $000005AE VOL: 0
;PCODE: $000005AF VOL: 0
; 0000 0659 		return 0;
;PCODE: $000005B0 VOL: 0
;PCODE: $000005B1 VOL: 0
;PCODE: $000005B2 VOL: 0
; 0000 065A 	else
;PCODE: $000005B3 VOL: 0
; 0000 065B 		return (long)((long)(4096*( long)adcbalanceresistor)/adcread-(long)adcbalanceresistor); //(3.3V - 4096À» 5V·Î È¯»êÇÏ¸é 6206)
;PCODE: $000005B4 VOL: 0
;PCODE: $000005B5 VOL: 0
;PCODE: $000005B6 VOL: 0
;PCODE: $000005B7 VOL: 0
;PCODE: $000005B8 VOL: 0
;PCODE: $000005B9 VOL: 0
;PCODE: $000005BA VOL: 0
;PCODE: $000005BB VOL: 0
;PCODE: $000005BC VOL: 0
;PCODE: $000005BD VOL: 0
;PCODE: $000005BE VOL: 0
; 0000 065C }
;PCODE: $000005BF VOL: 0
;PCODE: $000005C0 VOL: 0
;PCODE: $000005C1 VOL: 0
;PCODE: $000005C2 VOL: 0
;void adc_air(){
; 0000 065D void adc_air(){
;PCODE: $000005C3 VOL: 0
;PCODE: $000005C4 VOL: 0
; 0000 065E 		//calculated resistence depends on the sensor pulldown resistor
; 0000 065F 		long res;
; 0000 0660         val1 = adca_read(1);
;PCODE: $000005C5 VOL: 0
;	res -> Y+0
;PCODE: $000005C6 VOL: 0
;PCODE: $000005C7 VOL: 0
;PCODE: $000005C8 VOL: 0
; 0000 0661         res = adc_getresistence(val1, MQ135_PULLDOWNRES);
;PCODE: $000005C9 VOL: 0
;PCODE: $000005CA VOL: 0
;PCODE: $000005CB VOL: 0
;PCODE: $000005CC VOL: 0
;PCODE: $000005CD VOL: 0
; 0000 0662 
; 0000 0663 		//get ro
; 0000 0664 		mq135_ro = mq135_getro(res, MQ135_DEFAULTPPM);
;PCODE: $000005CE VOL: 0
;PCODE: $000005CF VOL: 0
;PCODE: $000005D0 VOL: 0
;PCODE: $000005D1 VOL: 0
;PCODE: $000005D2 VOL: 0
; 0000 0665 		//convert to ppm (using default ro)
; 0000 0666 		d = mq135_getppm(res, MQ135_DEFAULTRO);
;PCODE: $000005D3 VOL: 0
;PCODE: $000005D4 VOL: 0
;PCODE: $000005D5 VOL: 0
;PCODE: $000005D6 VOL: 0
;PCODE: $000005D7 VOL: 0
; 0000 0667        /*
; 0000 0668 		itoa(val1, printbuff);
; 0000 0669 		puts("ADC : ");
; 0000 066A         puts(printbuff);
; 0000 066B         puts(", ");
; 0000 066C 
; 0000 066D         ftoa(val1*0.0012,2,printbuff);
; 0000 066E         puts("V(5) : ");
; 0000 066F         puts(printbuff);
; 0000 0670         puts("V, ");
; 0000 0671 
; 0000 0672         ftoa(val1*0.0008,2,printbuff);
; 0000 0673         puts("V(3.3) : ");
; 0000 0674         puts(printbuff);
; 0000 0675         puts("V, ");
; 0000 0676 
; 0000 0677 		ltoa(res, printbuff);
; 0000 0678 		puts("RES : ");
; 0000 0679         puts(printbuff);
; 0000 067A         puts(", ");
; 0000 067B 
; 0000 067C 		ltoa(mq135_ro, printbuff);
; 0000 067D 		puts("ro : ");
; 0000 067E         puts(printbuff);
; 0000 067F         puts(", ");
; 0000 0680          */
; 0000 0681 }
;PCODE: $000005D8 VOL: 0
;PCODE: $000005D9 VOL: 0
;PCODE: $000005DA VOL: 0
;
;
;
;
;
;void main(void)
; 0000 0688 {
;PCODE: $000005DB VOL: 0
; 0000 0689 // Declare your local variables here
; 0000 068A unsigned char n;
; 0000 068B unsigned char ch[30]="";
; 0000 068C 
; 0000 068D // Interrupt system initialization
; 0000 068E // Optimize for speed
; 0000 068F #pragma optsize-
; 0000 0690 // Make sure the interrupts are disabled
; 0000 0691 #asm("cli")
;PCODE: $000005DC VOL: 0
;PCODE: $000005DD VOL: 0
;PCODE: $000005DE VOL: 0
;PCODE: $000005DF VOL: 0
;PCODE: $000005E0 VOL: 0
;	n -> R17
;	ch -> Y+0
;PCODE: $000005E1 VOL: 0
	cli
;PCODE: $000005E2 VOL: 0
; 0000 0692 // Low level interrupt: On
; 0000 0693 // Round-robin scheduling for low level interrupt: Off
; 0000 0694 // Medium level interrupt: Off
; 0000 0695 // High level interrupt: Off
; 0000 0696 // The interrupt vectors will be placed at the start of the Application FLASH section
; 0000 0697 n=(PMIC.CTRL & (~(PMIC_RREN_bm | PMIC_IVSEL_bm | PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm))) |
; 0000 0698 	PMIC_LOLVLEN_bm;
;PCODE: $000005E3 VOL: 1
;PCODE: $000005E4 VOL: 0
;PCODE: $000005E5 VOL: 0
;PCODE: $000005E6 VOL: 0
; 0000 0699 CCP=CCP_IOREG_gc;
;PCODE: $000005E7 VOL: 0
;PCODE: $000005E8 VOL: 0
; 0000 069A PMIC.CTRL=n;
;PCODE: $000005E9 VOL: 1
;PCODE: $000005EA VOL: 0
; 0000 069B // Set the default priority for round-robin scheduling
; 0000 069C PMIC.INTPRI=0x00;
;PCODE: $000005EB VOL: 0
;PCODE: $000005EC VOL: 1
; 0000 069D // Restore optimization for size if needed
; 0000 069E #pragma optsize_default
; 0000 069F 
; 0000 06A0 // System clocks initialization
; 0000 06A1 system_clocks_init();
;PCODE: $000005ED VOL: 0
; 0000 06A2 
; 0000 06A3 // Ports initialization
; 0000 06A4 ports_init();
;PCODE: $000005EE VOL: 0
; 0000 06A5 
; 0000 06A6 // Virtual Ports initialization
; 0000 06A7 vports_init();
;PCODE: $000005EF VOL: 0
; 0000 06A8 
; 0000 06A9 // Timer/Counter TCC0 initialization
; 0000 06AA tcc0_init();
;PCODE: $000005F0 VOL: 0
; 0000 06AB 
; 0000 06AC // RTC initialization
; 0000 06AD rtcxm_init();
;PCODE: $000005F1 VOL: 0
; 0000 06AE 
; 0000 06AF // USARTC0 initialization
; 0000 06B0 usartc0_init();
;PCODE: $000005F2 VOL: 0
; 0000 06B1 
; 0000 06B2 // USARTD0 initialization
; 0000 06B3 usartd0_init();
;PCODE: $000005F3 VOL: 0
; 0000 06B4 
; 0000 06B5 // ADCA initialization
; 0000 06B6 adca_init();
;PCODE: $000005F4 VOL: 0
; 0000 06B7 
; 0000 06B8 SCL_Direction = 1;                 // SCLÀº output
;PCODE: $000005F5 VOL: 0
;PCODE: $000005F6 VOL: 0
; 0000 06B9 
; 0000 06BA // Globally enable interrupts
; 0000 06BB #asm("sei")
;PCODE: $000005F7 VOL: 0
	sei
;PCODE: $000005F8 VOL: 0
; 0000 06BC 
; 0000 06BD 
; 0000 06BE while (1)
;PCODE: $000005F9 VOL: 0
; 0000 06BF       {
; 0000 06C0       // Place your code here
; 0000 06C1         if(sec>1){      // 2ÃÊ¸¶´Ù
;PCODE: $000005FA VOL: 0
;PCODE: $000005FB VOL: 0
;PCODE: $000005FC VOL: 0
; 0000 06C2             SHToperation();     // ¿Â½Àµµ ¼¾¼­ µ¿ÀÛ ¹× Ãâ·Â
;PCODE: $000005FD VOL: 0
; 0000 06C3             adc_dust(); // ¸ÕÁö¼¾¼­
;PCODE: $000005FE VOL: 0
; 0000 06C4             adc_air();   // °ø±âÇ°Áú(CO2¼¾¼­)
;PCODE: $000005FF VOL: 0
; 0000 06C5             //sprintf(ch,"%d, %2.3fV, %2.3fug",val0,val0*0.0008, val0*0.106);
; 0000 06C6             sprintf(ch,", %d, %d",dustDensity, d);    // dustDensity = 0.17*val0*(3.3/4096)-0.1 = 137*val0 - 100
;PCODE: $00000600 VOL: 0
;PCODE: $00000601 VOL: 0
;PCODE: $00000602 VOL: 0
;PCODE: $00000603 VOL: 0
;PCODE: $00000604 VOL: 0
;PCODE: $00000605 VOL: 0
;PCODE: $00000606 VOL: 0
;PCODE: $00000607 VOL: 0
;PCODE: $00000608 VOL: 0
;PCODE: $00000609 VOL: 0
;PCODE: $0000060A VOL: 0
;PCODE: $0000060B VOL: 0
;PCODE: $0000060C VOL: 0
;PCODE: $0000060D VOL: 0
; 0000 06C7             //sprintf(ch,"ppm : %3.2f",d);
; 0000 06C8             putstring(ch);        //  ¸ÕÁö¼¾¼­°ª Ãâ·Â
;PCODE: $0000060E VOL: 0
;PCODE: $0000060F VOL: 0
; 0000 06C9             putchar_usartd0(13);    // Wi-Fi CR
;PCODE: $00000610 VOL: 0
;PCODE: $00000611 VOL: 0
; 0000 06CA             putchar_usartd0(10);    // Wi-Fi LF
;PCODE: $00000612 VOL: 0
;PCODE: $00000613 VOL: 0
; 0000 06CB             putchar('\r');      // ½Ã¸®¾ó CR
;PCODE: $00000614 VOL: 0
;PCODE: $00000615 VOL: 0
; 0000 06CC             sec=0;
;PCODE: $00000616 VOL: 0
; 0000 06CD         }
; 0000 06CE 
; 0000 06CF       }
;PCODE: $00000617 VOL: 0
;PCODE: $00000618 VOL: 0
;PCODE: $00000619 VOL: 0
; 0000 06D0 }
;PCODE: $0000061A VOL: 0
;PCODE: $0000061B VOL: 0
;PCODE: $0000061C VOL: 0
;PCODE: $0000061D VOL: 0
